<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roulette Trend Tracker • FULL • Build: 2026-01-09 • CASH PRIORITY v14.0</title>
  <style>
    :root{color-scheme:dark; --bg:#0b1220; --card:#0f1a2e; --muted:#94a3b8; --txt:#e5e7eb; --accent:#60a5fa; --warn:#fbbf24; --danger:#ef4444; --ok:#34d399; --chip:#111c33; --border:#1f2a44;}
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#070b14,#0b1220 40%,#070b14);color:var(--txt)}
    .wrap{max-width:980px;margin:0 auto;padding:18px 14px 40px}
    h1{font-size:28px;margin:0 0 6px;letter-spacing:.2px}
    .build{margin-top:6px;color:#c7d2fe;font-weight:800;font-size:14px}
    .sub{color:var(--muted);font-size:12px;margin:8px 0 12px;line-height:1.35}
    .card{background:rgba(15,26,46,.88);border:1px solid var(--border);border-radius:16px;padding:14px;margin:12px 0;box-shadow:0 8px 28px rgba(0,0,0,.25)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;color:var(--muted)}
    .pill b{color:var(--txt)}
    .btn{appearance:none;border:1px solid var(--border);background:var(--chip);color:var(--txt);padding:10px 12px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.small{padding:6px 10px;font-size:12px;border-radius:10px}
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:rgba(96,165,250,.45);background:rgba(96,165,250,.18)}
    .btn.danger{border-color:rgba(239,68,68,.45);background:rgba(239,68,68,.12)}
    input[type="text"], textarea{width:100%;border-radius:14px;border:1px solid var(--border);background:#0b152b;color:var(--txt);padding:10px}
    textarea{min-height:92px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:860px){.grid{grid-template-columns:1.1fr .9fr}}
    .kbd{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;}
    .key{padding:12px 8px;border-radius:12px;border:1px solid var(--border);background:#0c1730;color:var(--txt);font-weight:900;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent}
    .key.green{background:rgba(16,185,129,.16);border-color:rgba(16,185,129,.35)}
    .key.zero{background:rgba(245,158,11,.16);border-color:rgba(245,158,11,.35)}
    .key:active{transform:translateY(1px)}
    .stat{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .box{background:#0c1730;border:1px solid var(--border);border-radius:14px;padding:10px}
    .k{color:var(--muted);font-size:11px}
    .v{font-size:16px;font-weight:900;margin-top:2px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hr{height:1px;background:var(--border);margin:12px 0}
    .topplays{display:grid;grid-template-columns:1fr;gap:8px}
    .playcard{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);padding:10px;border-radius:12px}
    .playhdr{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .tag{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);opacity:.9}
    .small{font-size:12px;opacity:.9;line-height:1.25}
    /* modal */
    #expModal{display:none;position:fixed;inset:0;z-index:9999;}
    #expBackdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
    #expCard{position:relative;max-width:720px;margin:8vh auto;background:#111827;color:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.45);padding:16px 16px 12px 16px}
    #expBody{margin:12px 0 0 0;white-space:pre-wrap;word-wrap:break-word;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;font-size:12px;line-height:1.35;background:rgba(255,255,255,.06);padding:12px;border-radius:12px;max-height:58vh;overflow:auto}
    /* Wheel modal */
    .modalOverlay{
      position:fixed; inset:0; z-index:9999;
      background:rgba(0,0,0,0.55);
      display:flex; align-items:center; justify-content:center;
      padding:14px;
      backdrop-filter: blur(6px);
    }
    .modalCard{
      width:min(680px, 100%);
      background:rgba(20,28,45,0.95);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      padding:14px;
    }
    .modalHeader{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Roulette Trend Tracker</h1>
    <div id="buildStamp" class="pill" style="display:inline-block;margin-top:6px">Build: 2026-01-09 • FULL • CASH PRIORITY v14.0</div>
    <div class="build">FULL TRACKER — CASH PRIORITY + NEW STRATEGIES • v14.0</div>
    <div class="sub">Build date: <b>2026-01-07</b>. Tap spins on the keypad. Tracks last 10/15/20: columns, dozens, double-streets, red/black, high/low, even/odd, Junko quadrants. Saves on-device.</div>

    <div class="card">
      <div class="row">
        <div class="pill">Window: <b id="winLabel">Last 15</b></div>
        <div class="pill">Spins: <b id="spinCount">0</b></div>
        <div class="pill">Session: <b id="sessionCount">0</b></div>
        <div class="pill">Green: <b id="greenCount">0</b></div>
      </div>
      <div class="row" style="margin-top:10px">
        <label class="pill" style="gap:10px; align-items:center; width:100%">
          Casino:
          <input id="casinoInput" type="text" placeholder="e.g., Caesars / Harrah’s Joliet" style="flex:1; min-width:180px" />
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="undoBtn" type="button">Undo</button>
        <button class="btn danger" id="clearBtn" type="button">Clear</button>
        <button class="btn" id="use15Btn" type="button">Use last 15</button>
        <button class="btn" id="use10Btn" type="button">Use last 10</button>
        <button class="btn" id="use20Btn" type="button">Use last 20</button>
        <button class="btn" id="newSessionBtn" type="button">New Session</button>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div style="font-weight:900;margin-bottom:8px">Quick input</div>
        <div class="row">
          <input id="manualInput" type="text" placeholder="Type: 0–36 or 00" inputmode="text" />
          <button class="btn primary" id="addManualBtn" type="button">Add</button>
        </div>
        <div class="small" style="margin-top:8px">Tip: On iPhone, the keypad is usually fastest. Manual input is a backup.</div>

        <div class="hr"></div>

        <div id="keypadAnchor" style="font-weight:900;margin-bottom:8px">Tap keypad</div>
        <div class="kbd" id="kbd"></div>
      </div>

      <div class="card">
        <div style="font-weight:900;margin-bottom:8px">Trend + tracking</div>

        <div class="stat">
          <div class="box">
            <div class="k">Recommended play</div>
            <div class="v" id="recommend">Sit out</div>
            <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
              <button id="primaryExplainBtn" class="btn small" type="button" style="display:none">Explain</button>
            </div>
            <div class="k" id="reason" style="margin-top:8px">No data yet.</div>
          </div>
          <div class="box">
            <div class="k">Table state</div>
            <div class="v" id="tableState">—</div>
            <div class="k" id="tableStateDetail" style="margin-top:8px">—</div>
            <div class="k" id="repeatsInfo" style="margin-top:8px"></div>
            <div class="k" id="streetRepeatsInfo" style="margin-top:4px"></div>
            <div class="k" id="hydraCold4" style="margin-top:4px"></div>
            <div class="k" id="sinceGreen" style="margin-top:4px"></div>
          </div>
        <div id="trendAlert" class="alert" style="display:none;margin-top:10px">
          <div style="font-weight:800;margin-bottom:4px">Trend change alert</div>
          <div id="trendAlertText">—</div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" id="trendDismissBtn" type="button">Dismiss</button>
          </div>
        </div>
        
          <div class="box">
            <div class="k">Table state</div>
            <div class="v" id="state">—</div>
            <div class="k" id="state2">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <div style="font-weight:900;margin-bottom:8px">Top 3 strategies right now</div>
        <div id="topPlays" class="topplays"></div>

        <div class="hr"></div>

        <div class="stat">
          <div class="box"><div class="k">Columns (C1/C2/C3)</div><div class="v mono" id="cols">0 / 0 / 0</div></div>
          <div class="box"><div class="k">Dozens (D1/D2/D3)</div><div class="v mono" id="doz">0 / 0 / 0</div></div>
          <div class="box"><div class="k">Double Streets (per dozen)</div><div class="v mono" id="ds">D1 — | D2 — | D3 —</div></div>
          <div class="box"><div class="k">Red / Black</div><div class="v mono" id="rb">0 / 0</div></div>
          <div class="box"><div class="k">High / Low</div><div class="v mono" id="hl">0 / 0</div></div>
          <div class="box"><div class="k">Even / Odd</div><div class="v mono" id="eo">0 / 0</div></div>
          <div class="box"><div class="k">Junko quadrants</div><div class="v mono" id="junko">GN 0 | HO 0 | LO 0 | M 0</div></div>
        </div>

        <div class="hr"></div>

        <div style="font-weight:900;margin-bottom:8px">Last 20 (newest first)</div>
        <textarea id="lastList" readonly placeholder="No spins yet."></textarea>

        <div class="hr"></div>

        <div class="row" style="gap:10px;flex-wrap:wrap">
          <button class="btn" id="copyCsvBtn" type="button">Copy CSV</button>
          <button class="btn" id="downloadCsvBtn" type="button">Download CSV</button>
          <button class="btn" id="wheelViewBtn" type="button">Wheel View (Last 20)</button>
        </div>

        <div class="card" style="margin-top:14px;">
          <div style="font-weight:900">Import session CSV (append to history)</div>
          <div class="small" style="margin-top:6px">Paste CSV with header: <span class="mono">number,casino,date,time,session_id</span>, then tap Import.</div>
          <textarea id="importArea" style="height:120px; margin-top:10px;" placeholder="Paste CSV here..."></textarea>
          <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
            <button class="btn primary" id="importBtn" type="button">Import CSV</button>
            <button class="btn" id="clearImportBtn" type="button">Clear Import Box</button>
          </div>
          <div class="small" id="importStatus" style="margin-top:8px;"></div>
        </div>

      </div>
    </div>
  </div>

  <!-- Explain modal -->
  <div id="expModal">
    <div id="expBackdrop"></div>
    <div id="expCard">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
        <div id="expTitle" style="font-weight:900;font-size:16px;line-height:1.2">Strategy details</div>
        <button id="expClose" class="btn small" type="button" style="background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.18);">Close</button>
      </div>
      <pre id="expBody"></pre>
    </div>
  </div>

  <!-- Wheel View Modal -->
  <div id="wheelModal" class="modalOverlay" style="display:none;">
    <div class="modalCard">
      <div class="modalHeader">
        <div>
          <div class="h2" style="margin:0;">American Wheel — Last 20</div>
          <div class="hint" id="wheelSubtitle" style="margin-top:4px;">Radial bars show hit count per pocket (most recent 20 spins).</div>
        </div>
        <button class="btn" id="wheelCloseBtn" type="button">Close</button>
      </div>
      <canvas id="wheelCanvas" width="420" height="420" style="width:100%; max-width:520px; border-radius:16px; background:rgba(255,255,255,0.03);"></canvas>
      <div class="hint" style="margin-top:10px;">
        Tip: Longer / more stacked bars = more hits in the last 20. Green pockets are 0 and 00.
      </div>
    </div>
  </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const STORAGE_KEY = "roulette_trend_tracker_base_keypad_tracking_v1";
  const ACTIVE_KEY = "roulette_active_strategy_v1";
  const RED = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  const BLACK = new Set([2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35]);

  // Junko quadrants mapping (as previously used)
  const GN = new Set(["00",0,1,2,9,10,13,14,27,28]);
  const HO = new Set([24,25,26,29,30,33,34,35,36]);
  const LO = new Set([3,4,8,11,12,15,16,22,23]);
  const MID= new Set([5,6,7,17,18,19,20,21,31,32]);

  let spins = []; // newest-first: {n,t,s}
  let windowN = 15;
  let sessionId = 1;

  const $ = (id) => document.getElementById(id);
  const trendDismissBtn = $("trendDismissBtn");
  const trendAlert = $("trendAlert");

  function numToKey(n) {
    if (n === "00") return "00";
    if (typeof n === "string" && n.trim() === "00") return "00";
    const v = Number(n);
    return Number.isFinite(v) ? v : null;
  }

  // Normalize spin inputs across the app:
  // - Accepts numbers or strings ("00", "0", "99", etc.)
  // - Treats 99 as "00" (legacy encoding)
  function normSpin(v) {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (s === "") return null;
    if (s === "00" || s === "99") return "00";
    if (s === "0") return 0;
    const n = Number(s);
    if (!Number.isFinite(n)) return null;
    if (Number.isInteger(n) && n >= 0 && n <= 36) return n;
    return null;
  }
  function normalizeSpin(v) { return normSpin(v); }

// Return the newest N values from a newest-first array.
function lastN(arr, n){
  if(!Array.isArray(arr)) return [];
  const k = Math.max(0, Math.min(arr.length, Number(n)||0));
  return arr.slice(0, k);
}



  function isGreen(n) { return (n === "00" || Number(n) === 0); }
  function isRed(n)   { return (n !== "00" && RED.has(Number(n))); }
  function isBlack(n) { return (n !== "00" && BLACK.has(Number(n))); }
  function isHigh(n)  { return (n !== "00" && Number(n) >= 19); }
  function isLow(n)   { return (n !== "00" && Number(n) >= 1 && Number(n) <= 18); }
  function isEven(n)  { return (n !== "00" && Number(n) !== 0 && Number(n)%2===0); }
  function isOdd(n)   { return (n !== "00" && Number(n)%2===1); }

  function colOf(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    const r = v % 3;
    return r === 1 ? 1 : (r === 2 ? 2 : 3);
  }
  function dozenOf(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    return v<=12 ? 1 : (v<=24 ? 2 : 3);
  }
  function streetId(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    return Math.floor((v-1)/3) + 1; // 1..12
  }
  function junkoBucket(n) {
    const k = (n==="00") ? "00" : Number(n);
    if (GN.has(k)) return "GN";
    if (HO.has(k)) return "HO";
    if (LO.has(k)) return "LO";
    if (MID.has(k)) return "M";
    return null;
  }

  function dsKey(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    const d = v<=12 ? 1 : (v<=24 ? 2 : 3);
    const base = (d-1)*12;
    const a = base+1, b = base+4, c = base+7;
    if (v>=a && v<=a+5) return {d:d, i:1};
    if (v>=b && v<=b+5) return {d:d, i:2};
    if (v>=c && v<=c+5) return {d:d, i:3};
    return {d:d, i:2};
  }
  function dsCounts(vals) {
    const out = {d1:[0,0,0], d2:[0,0,0], d3:[0,0,0]};
    vals.forEach((n)=>{
      const k = dsKey(n);
      if(!k) return;
      const arr = (k.d===1?out.d1:(k.d===2?out.d2:out.d3));
      arr[k.i-1] += 1;
    });
    return out;
  }

  function counts(vals) {
    const c = {c1:0,c2:0,c3:0,d1:0,d2:0,d3:0,red:0,black:0,high:0,low:0,even:0,odd:0,gn:0,ho:0,lo:0,m:0,green:0};
    vals.forEach((n)=>{
      if(isGreen(n)) c.green++;
      const col = colOf(n); if(col===1)c.c1++; if(col===2)c.c2++; if(col===3)c.c3++;
      const d = dozenOf(n); if(d===1)c.d1++; if(d===2)c.d2++; if(d===3)c.d3++;
      if(isRed(n)) c.red++;
      if(isBlack(n)) c.black++;
      if(isHigh(n)) c.high++;
      if(isLow(n)) c.low++;
      if(isEven(n)) c.even++;
      if(isOdd(n)) c.odd++;
      const jb = junkoBucket(n);
      if(jb==="GN") c.gn++;
      if(jb==="HO") c.ho++;
      if(jb==="LO") c.lo++;
      if(jb==="M") c.m++;
    });
    return c;
  }

  function repeatNumberInfo(vals, lookback) {
    if(vals.length<2) return {flag:false, text:"—"};
    const newest = vals[0];
    const slice = vals.slice(1, Math.min(vals.length, lookback));
    for(let i=0;i<slice.length;i++) {
      if(slice[i]===newest) return {flag:true, text:String(newest)+" repeated within "+(i+1)+" spins"};
    }
    return {flag:false, text:"—"};
  }
  function repeatStreetInfo(vals, lookback) {
    if(vals.length<2) return {flag:false, text:"—"};
    const s0 = streetId(vals[0]);
    if(!s0) return {flag:false, text:"—"};
    for(let i=1;i<Math.min(vals.length, lookback); i++) {
      const si = streetId(vals[i]);
      if(si && si===s0) return {flag:true, text:"Street "+s0+" repeated within "+i+" spins"};
    }
    return {flag:false, text:"—"};
  }

  const STRATEGY_DETAILS = {
    "6 Diamonds + 0/00 (Primary)":
`6 Diamonds + 0/00 (Primary)

Default forced-play strategy (COMP)
- Wide coverage grinder for survivability.
- Progression capped at Step 1 in COMP mode.

Core
- Use your 6 Diamonds corner structure.
- Add 0/00 split as your table allows (American wheel).

Exit / Mode rules
- Stay in COMP when CASH score < 85 or during cooldowns.
- Switch to CASH only after a reset/completed progression/milestone (per session rules).`,

    "Point Pusher":
`Point Pusher (COMP)

Profile
- Column + corners + basket.
- Smooth ADT profile.
- Flat betting.

Use when
- COMP mode default/fallback.
- Table is flat/choppy without a strong bias.`,

    "Junko Dry (Flat)":
`Junko Dry (COMP)

Use when
- Quadrant droughts / weak Junko signal.
- Low volatility, slow bleed.

Rule
- Flat only.
- Recompute every spin using your chosen window.`,

    "DS Cash Power (Base Only)":
`DS Cash Power (COMP Base)

Use when
- Mild clustering is present but you do NOT want ladder risk.

Rule
- Base engagement only (no escalation).
- Reset/exit on any hostile shift.`,

    "Minimum Bet Placeholder":
`Minimum Bet Placeholder (COMP)

Use when
- Extreme noise / greens heavy.
- Near stop-loss conditions.

Rule
- Minimum engagement to stay betting.
- Focus on survivability until structure improves.`,

    "Slow & Steady (Structural Bias)":
`Slow & Steady (CASH)

Score driver
- Dozen / Column concentration.

Use when
- D or C dominance is extreme and CASH qualifies (rank #1, score ≥ 85).

Constraints
- Bet cap: 4u per bet.
- Immediate exit on structure break.`,

    "DS Cash Power (Street Cluster)":
`DS Cash Power (CASH)

Score driver
- Double street clustering + repeats.

Use when
- One DS bucket is clearly dominant and CASH qualifies.

Abort
- If DS score weakens at reassessment.`,

    "Gold Mine (Even-Money Compression)":
`Gold Mine (CASH)

Score driver
- High / Low dominance.

Rules
- Option A (no hedge).
- Exit as soon as dominance drops.`,

    "Follow-the-Leader 50/50":
`Follow-the-Leader 50/50 (CASH)

Score driver
- Run length + dominance.

Use when
- Run ≥ 3 AND dominance ≥ 12/20 and CASH qualifies.

Exit
- First streak break.`,

    "Junko Hot (Quadrant Momentum)":
`Junko Hot (CASH)

Score driver
- Quadrant momentum (e.g., ≥ strong threshold).

Rules
- Flat only.
- Short leash (10–15 spins).
- Exit immediately if score degrades.`,

    "Win 28 (Coverage Probe)":
`Win 28 (CASH)

Score driver
- Coverage / dispersion (last-20).

Rules
- Flat only.
- Diagnostic + cash shot.
- Abort early on hostile start.`,

    "Anti-Last-Dozen (Mean Reversion)":
`Anti-Last-Dozen (CASH)

Score driver
- Rotational / flat table.

Rules
- Conservative ladder.
- Hard abort on ladder failure.
- CASH only if it qualifies (rank #1, score ≥ 85).`,

    "Disappearing Streets (Anti-Repeat)":
`Disappearing Streets (CASH)

Score driver
- No repeat streets + flat table.

Rules
- Remove winners.
- Abort if repeats emerge.`,

    "6 Diamonds (Corner Core)":
`6 Diamonds (Corner Core) — FIXED CORNERS

Corners (fixed 6)
- 1/2/3/5
- 7/8/9/11
- 13/14/15/17
- 19/20/21/23
- 25/26/27/29
- 31/32/33/35

How to bet
- Flat bet 1 unit per corner (your unit size).
- 6 corners total.

Progression (simple, session-safe)
- After a losing spin: +1 unit to ALL 6 corners.
- After a winning spin: −1 unit to ALL 6 corners (minimum 1 unit).

Stop/Reset
- Reset to 1 unit when you’re back near session high, or after any strong recovery.`,

    "Hot Quadrant last-15 (Option A)":
`Hot Quadrant last-15 (Option A)

Trigger
- In last 15 spins, one Junko quadrant has >= 6 hits.

How to bet
- Bet 1 unit on 5 numbers inside the hottest quadrant.
- Optional: if repeats are present, add 2 neighbor numbers inside that quadrant.

Exit / Reset
- If the hot quadrant drops below 6/15, stop and re-evaluate.
- Reset to base on any meaningful recovery (near session high).`,

    "Junko Quadrants (hot/dry)":
`Junko Quadrants (hot/dry)

Quadrants
- GN: 00, 0, 1, 2, 9, 10, 13, 14, 27, 28
- HO: 24,25,26,29,30,33,34,35,36
- LO: 3,4,8,11,12,15,16,22,23
- M: 5,6,7,17,18,19,20,21,31,32

How to use
- If HOT: bet a subset of numbers inside the hottest quadrant (5–7 numbers).
- If DRY: avoid the driest quadrant and play outside it with your preferred structure.

Exit
- Recompute every spin based on last-15 window.`,

    "DS Cash Power":
`DS Cash Power (summary)

Entry
- Based on last-15: in each dozen, identify the hottest double street (6-line).

Bets (base example)
- 3 double streets (one per dozen): 1 unit each.
- Optional corner scaffold per your DSCP variant.

Progression
- Use your DSCP progression rule (step after consecutive losses).
- Reset when near session high.`,

    "Moving Streets (Adjacent Fade)":
`Moving Streets (Adjacent Fade)

Entry
- ONLY when there are NO repeat streets in the last 5 spins (dispersion / choppy).

Rule
- Look at the last 3 streets that hit (convert each number to its street).
- DO NOT bet those 3 streets.
- Instead, bet the adjacent street(s) next to each of those streets.
  Example: if Street 6 hit, adjacent are Streets 5 and 7.
- Merge duplicates; keep total streets reasonable (6–8 streets typical).

Exit
- If street repeats begin (repeat streets flag turns on), stop and switch strategies.`,

    "Sit out":
`Sit out
- Keep logging spins until a repeat or concentration appears.`
  
    ,
    "Corners + Double Streets (Follow the Leader — Locked Until Loss)":
`Corners + Double Streets (Follow the Leader — Locked Until Loss)

Category: CASH / Grind
Wheel: American
Table requirement: $10 table allowing ≥ $15 total inside bets.

Base (Level 1) — TOTAL $16 inside
- Double Streets: 4 adjacent non-overlapping double streets × $3 = $12
- Corners: 4 paired corners × $1 = $4

Double Street ↔ Corner pairings
- 1–6   → corner 2/6   (2,3,5,6)
- 7–12  → corner 8/12  (8,9,11,12)
- 13–18 → corner 14/18 (14,15,17,18)
- 19–24 → corner 20/24 (20,21,23,24)
- 25–30 → corner 26/30 (26,27,29,30)
- 31–36 → corner 32/36 (32,33,35,36)

How to select the DS block (FOLLOW THE LEADER)
1) Look at the previous 2 spins (ignore 0/00).
2) Identify their double streets (one of the 6 DS above).
3) Choose a block of 4 ADJACENT double streets that includes both if possible.
   If not possible, include the most recent spin’s double street.
4) LOCK this DS block until a LOSS occurs.

Numbers to bet (depends on the locked DS block)
- Bet the 4 double streets in your locked block (all numbers inside them).
- Also bet the matching 4 corners for those same 4 double streets.

Progression (multiplier m)
- Start m = 1.
- Increase m by +1 after every 2 consecutive losses.
- Ladder down m by −1 after any win (min m = 1).

Bet sizing at level m
- Double Street bet = $3 × m (each of the 4 double streets)
- Corner bet       = $1 × m (each of the 4 corners)

Reset
- Reset to m=1 when session profit ≥ $30.
- Reset clears loss counter.
- DS block remains unless the NEXT spin is a loss.

Session rules
- Cashout: +$50
- Stop-loss: −$300 (end session immediately).`,
    "Moon Dance 2S/Dozen (Junko Base)":
`Moon Dance 2S/Dozen — Junko Base (CASH)

Core idea
- For each dozen, pick the 2 least-hit streets in the prior 15 spins.
- That yields 6 streets = 18 numbers (straight-up coverage).

Bet
- Bet $b on each of the 18 numbers.
- Start b=1; on a full miss (no 18-hit and no 0/00): b doubles.
- Win if any of the 18 hits OR 0/00 hits: reset b=1 and recompute streets next cycle.

0/00 bailout
- Only when b >= 8: add $2 on 0 and $2 on 00.

Exits
- Cash out +$100 (after spin), stop loss −$200 with guardrail.`,

    "Trinity–Junko v2":
`Trinity–Junko v2 (CASH)

Double Streets
- Bet DS 1–6 and 7–12 (two 6-lines).
- ds_unit starts 1; +1 each spin with NO DS hit; cap 5.
- If any DS hits (1–12): remove BOTH DS until next reset; ds_unit=1.

Corners (8)
- 13/17, 14/18, 19/23, 20/24, 25/29, 26/30, 31/35, 32/36
- Remove any corner(s) that hit.
- corner_unit doubles every 3 spins (win or loss); cap 16.

Resets
- Reset DS+corners+units at +$15 milestones (15/30/45/60/75/90) OR when ≤2 corners remain.

Exits
- Cashout +$90 (after spin), stop loss −$200 with guardrail.`,

    "Opposite-Segment Contrarian (Option 1)":
`Opposite-Segment Contrarian (CASH)

Segments (00 encoded as 99 in data)
A = 13, 1, 00, 27, 10, 9, 28, 0, 2, 14
B = 31, 18, 6, 21, 33, 17, 5, 22, 32, 20
C = 25, 29, 12, 8, 19, 26, 30, 11, 7
D = 36, 24, 3, 15, 34, 35, 23, 4, 16
Opposite: A↔C, B↔D

Entry
- When hottest segment in last-15 has >= 6 hits, bet the opposite segment.

Bet
- $u per number in the bet segment.
- Escalation: +1u after 3 consecutive losing bet-spins.

Exits
- Cashout +$100 (after spin), stop loss −$200 with guardrail.`,

    "Corners + Double Streets (Follow the Leader)":
`Corners + Double Streets — Follow the Leader (CASH/GRIND)

Base (Level 1)
- 4 adjacent DS × $3 each + paired corners × $1 each.

Pairings
1–6→2/6 (2,3,5,6)
7–12→8/12 (8,9,11,12)
13–18→14/18 (14,15,17,18)
19–24→20/24 (20,21,23,24)
25–30→26/30 (26,27,29,30)
31–36→32/36 (32,33,35,36)

Selection
- Use previous 2 spins to select a 4-DS adjacent block that includes both if possible; else include the most recent.
- LOCK DS block until a loss; recalc only after a losing spin.

Progression
- Multiplier m starts 1; +1 after every 2 consecutive losses.
- Ladder down m −1 after any win (min 1).
- Bets: DS=$3*m, corners=$1*m.

Exits
- Cashout +$50, stop loss −$300.`,

  
  "Dirty Bird — Cold Dozen Switch (DB-CDS)": {
    type: "Cash / Comp (10 straight-ups)",
    trigger: "After 15 non-green spins; default bet coldest dozen. Switch to hottest dozen when coldest hits ≤3 in last-15.",
    howTo: [
      "Warmup: record spins until you have 15 NON-GREEN results (ignore 0 and 00).",
      "Compute dozen counts over those 15 non-green spins.",
      "If the coldest dozen has ≤3 hits: SWITCH mode → bet the HOTTEST dozen, leaving off the 2 hottest numbers in that dozen.",
      "Otherwise: COLD mode → bet the COLDEST dozen, leaving off the 2 coldest numbers in that dozen.",
      "Bet the remaining 10 numbers straight-up at unit u.",
      "Progression (Comp variant): after 3 consecutive misses, double u; any hit resets u=1.",
      "Session exits: Cashout/Stoploss per your tracker profile; obey guardrail."
    ],
    bets: "10 straight-ups (10 numbers) — tracker will show: dozen, 2 excluded numbers, and the 10 numbers to bet.",
    notes: "Green (0/00) is ignored for counts; 00 is encoded as 99 in data inputs."
  },
};

  function openExplain(title, body) {
    $("expTitle").textContent = title || "Strategy details";
    $("expBody").textContent = body || "";
    $("expModal").style.display = "block";
  }
  function closeExplain() {
    $("expModal").style.display = "none";
  }
  $("expClose").addEventListener("click", closeExplain);
  $("expBackdrop").addEventListener("click", closeExplain);

  function showExplain(name) {
    // normalize dynamic names (if ever added later)
    let key = name;
    if (key && key.indexOf("Hot Quadrant")===0) key = "Hot Quadrant last-15 (Option A)";
    const body = STRATEGY_DETAILS[key] || STRATEGY_DETAILS[name] || ("No details available for: " + name);
    openExplain(name, body);
  }

  function save() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        spins, windowN, sessionId, casino: $("casinoInput").value || ""
      }));
    } catch(_) {}
  }

  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(Array.isArray(obj.spins)) {
        spins = obj.spins.map(x => {
          if(!x) return null;
          if(typeof x === "string" || typeof x === "number") return {n:numToKey(x), t:Date.now(), s:1};
          return {n:numToKey(x.n), t:Number(x.t)||Date.now(), s:Number(x.s)||1};
        }).filter(x => x && x.n!==null);
      }
      if([10,15,20].includes(obj.windowN)) windowN = obj.windowN;
      if(Number.isFinite(obj.sessionId)) sessionId = Number(obj.sessionId);
      if(typeof obj.casino === "string") $("casinoInput").value = obj.casino;
    } catch(_) {}
  }

  function windowValues() {
    return spins.slice(0, windowN).map(x => x.n);
  }

  function buildKeypad() {
    const kbd = $("kbd");
    const keys = ["00",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36];
    kbd.innerHTML = "";
    keys.forEach(k => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "key";
      if(k==="00") b.className += " zero";
      if(k===0) b.className += " green";
      b.textContent = String(k);
      // pointer + click (iOS Safari safe)
      b.addEventListener("click", () => addSpin(k), {passive:true});
      b.addEventListener("touchend", (e) => { e.preventDefault(); addSpin(k); }, {passive:false});
      kbd.appendChild(b);
    });
  }

  function addSpin(val) {
    const k = numToKey(val);
    if(k===null) return;
    spins.unshift({ n:k, t:Date.now(), s:sessionId });
    if(spins.length > 5000) spins = spins.slice(0,5000);
    save();
    render();
  }

  function undo() {
    if(spins.length===0) return;
    spins.shift();
    save();
    render();
  }

  function clearAll() {
    if(!confirm("Clear all spins?")) return;
    spins = [];
    sessionId = 1;
    save();
    render();
  }

  function newSession() {
    sessionId += 1;
    save();
    render();
  }

  function csvDate(t) {
    const d = new Date(t);
    const yyyy = String(d.getFullYear());
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${yyyy}-${mm}-${dd}`;
  }
  function csvTime(t) {
    const d = new Date(t);
    const hh = String(d.getHours()).padStart(2,'0');
    const mi = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mi}:${ss}`;
  }
  function toCsv() {
    const casino = ($("casinoInput").value||"").replace(/"/g,'""');
    const lines = ["number,casino,date,time,session_id"];
    spins.slice().reverse().forEach(x => {
      const n = (x.n==="00") ? "00" : String(x.n);
      lines.push(`${n},"${casino}",${csvDate(x.t)},${csvTime(x.t)},${x.s}`);
    });
    return lines.join("\n");
  }
  async function copyCsv() {
    const csv = toCsv();
    try {
      await navigator.clipboard.writeText(csv);
      alert("CSV copied.");
    } catch(_) {
      $("lastList").value = csv;
      $("lastList").focus();
      $("lastList").select();
      alert("Clipboard blocked. CSV placed in the box; copy manually.");
    }
  }
  function downloadCsv() {
    const blob = new Blob([toCsv()], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "roulette_spins_ALL.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  // CSV import (append + dedupe)
  function parseCsvLine(line) {
    const out = [];
    let i=0, cur="", inQ=false;
    while(i<line.length) {
      const ch = line.charAt(i);
      if(inQ) {
        if(ch === '"') {
          if(i+1<line.length && line.charAt(i+1)==='"') { cur+='"'; i+=2; continue; }
          inQ=false; i++; continue;
        }
        cur+=ch; i++; continue;
      } else {
        if(ch === '"') { inQ=true; i++; continue; }
        if(ch === ',') { out.push(cur); cur=""; i++; continue; }
        cur+=ch; i++; continue;
      }
    }
    out.push(cur);
    return out;
  }
  function parseNumberCell(cell) {
    const t = String(cell||"").trim();
    if(t==="00") return "00";
    const n = Number(t);
    if(!Number.isFinite(n)) return null;
    if(n===0) return 0;
    if(n>=1 && n<=36) return n;
    return null;
  }
  function parseTimestamp(dateStr, timeStr) {
    const ds = String(dateStr||"").trim();
    const ts = String(timeStr||"").trim();
    const iso = ds + "T" + ts;
    const ms = Date.parse(iso);
    if(Number.isFinite(ms)) return ms;
    // fallback
    const p = ds.split("-");
    const q = ts.split(":");
    if(p.length===3 && q.length>=2) {
      const y=Number(p[0]), m=Number(p[1])-1, d=Number(p[2]);
      const hh=Number(q[0]), mi=Number(q[1]), ss=Number(q[2]||0);
      return new Date(y,m,d,hh,mi,ss).getTime();
    }
    return Date.now();
  }
  function importCsvText(text) {
    const raw = String(text||"").trim();
    if(!raw) return {added:0, skipped:0, msg:"Nothing to import."};
    const lines = raw.split(/\r?\n/).filter(x => String(x).trim().length>0);
    if(lines.length < 2) return {added:0, skipped:0, msg:"CSV needs a header + at least 1 row."};

    let startIdx = 0;
    const h = lines[0].toLowerCase();
    if(h.includes("number") && h.includes("session")) startIdx = 1;

    const seen = new Set(spins.map(x => `${String(x.n)}|${String(x.t)}|${String(x.s)}`));
    let added=0, skipped=0;
    let casinoFromFile = null;

    for(let r=startIdx; r<lines.length; r++) {
      const cols = parseCsvLine(lines[r]);
      if(cols.length < 5) { skipped++; continue; }
      const n = parseNumberCell(cols[0]);
      if(n===null) { skipped++; continue; }
      const casino = String(cols[1]||"").trim();
      if(casino && casinoFromFile===null) casinoFromFile = casino;
      const t = parseTimestamp(cols[2], cols[3]);
      let s = Number(String(cols[4]||"").trim());
      if(!Number.isFinite(s)) s = 1;

      const key = `${String(n)}|${String(t)}|${String(s)}`;
      if(seen.has(key)) { skipped++; continue; }
      spins.push({n,t,s});
      seen.add(key);
      added++;
    }

    spins.sort((a,b)=>b.t-a.t);
    if(casinoFromFile && (!$("casinoInput").value || !$("casinoInput").value.trim())) {
      $("casinoInput").value = casinoFromFile;
    }
    save();
    render();
    return {added, skipped, msg:`Imported ${added} spins (skipped ${skipped}).`};
  }

  // Strategy scoring (simple but consistent with earlier intent)
    // Strategy scoring with CASH/COMP gate (Top 8 CASH). CASH is eligible only if it is #1 overall AND score >= 85.
  // Strategy scoring with CASH priority + suppression.
// CASH is eligible only if the chosen CASH strategy is #1 overall AND score >= 85.
const CASH_PRIORITY = [
  "Hydra v1.5B — Hybrid Switch",
  "Hydra v1.5B — Columns (Fixed)",
  "Corners + DS Tightened Variant",
  "Junko 10 to Win (Quadrant-Gated)",
  "Moon Dance 2S/Dozen (Junko Base)",
  "Dirty Bird — Cold Dozen Switch (DB-CDS)",
  "Trinity–Junko v2",
  "Opposite-Segment Contrarian (Option 1)",
  "Disappearing Streets (Comp Builder)",
  "Junko Hot (Quadrant Momentum)",
  "Slow & Steady (Structural Bias)",
];

function streetKey(n){
  const s = streetId(n);
  if(!s) return null;
  // map street number to dozen street index 1..4
  // Streets: 1-4 in dozen1, 5-8 dozen2, 9-12 dozen3 (by street)
  // But we want within-dozen: 1-4, 5-8, 9-12 per dozen in number-space:
  // StreetId already 1..12 with 1=1-3 ... 12=34-36
  const within = ((s-1) % 4) + 1; // 1..4
  const dozen = s<=4 ? 1 : (s<=8 ? 2 : 3);
  return {dozen, within, street: s};
}

function leastTwoStreetsPerDozen(last15){
  const counts = {1:[0,0,0,0], 2:[0,0,0,0], 3:[0,0,0,0]};
  last15.forEach(n=>{
    const k = streetKey(n);
    if(!k) return;
    counts[k.dozen][k.within-1] += 1;
  });
  // pick two least-hit within each dozen; ties -> lower within index
  const picks = {};
  [1,2,3].forEach(d=>{
    const arr = counts[d].map((c,i)=>({c,i:i+1}));
    arr.sort((a,b)=> (a.c-b.c) || (a.i-b.i));
    picks[d] = [arr[0].i, arr[1].i];
  });
  return {counts, picks};
}

function numbersForDozenStreet(dozen, within){
  // within 1..4 for a dozen => streets ranges in number-space
  const base = (dozen-1)*12;
  const start = base + (within-1)*3 + 1;
  return [start,start+1,start+2];
}

function moonDanceNumbers(last15){
  const {picks} = leastTwoStreetsPerDozen(last15);
  const nums = [];
  [1,2,3].forEach(d=>{
    picks[d].forEach(within=>{
      nums.push(...numbersForDozenStreet(d,within));
    });
  });
  return nums; // 18 nums
}

// Opposite-Segment mapping (00 handled as "00" string in this tracker)
const SEG_A = new Set([13,1,"00",27,10,9,28,0,2,14]);
const SEG_B = new Set([31,18,6,21,33,17,5,22,32,20]);
const SEG_C = new Set([25,29,12,8,19,26,30,11,7]);
const SEG_D = new Set([36,24,3,15,34,35,23,4,16]);
const SEG_ORDER = ["A","B","C","D"];
function segmentOf(n){
  const k = (n==="00") ? "00" : Number(n);
  if(SEG_A.has(k)) return "A";
  if(SEG_B.has(k)) return "B";
  if(SEG_C.has(k)) return "C";
  if(SEG_D.has(k)) return "D";
  return null;
}
function oppositeSeg(seg){ return seg==="A"?"C":(seg==="C"?"A":(seg==="B"?"D":"B")); }
function segNumbers(seg){
  const map = {A:[13,1,"00",27,10,9,28,0,2,14], B:[31,18,6,21,33,17,5,22,32,20], C:[25,29,12,8,19,26,30,11,7], D:[36,24,3,15,34,35,23,4,16]};
  return map[seg] || [];
}

function dsRangeOf(n){
  if(n==="00"||n===0) return null;
  const v = Number(n);
  if(!(v>=1 && v<=36)) return null;
  const s = streetId(v); // 1..12
  if(!s) return null;
  const dsStartStreet = (s%2===1) ? s : (s-1); // odd street starts DS
  const a = (dsStartStreet-1)*3 + 1;
  const b = a+5;
  return {start:a, end:b, dsStreetStart: dsStartStreet}; // e.g., 1-6, 7-12, ...
}
function dsKeyLabel(r){ return r ? `${r.start}-${r.end}` : null; }

function cornersForDSRange(label){
  const map = {
    "1-6":[2,3,5,6],
    "7-12":[8,9,11,12],
    "13-18":[14,15,17,18],
    "19-24":[20,21,23,24],
    "25-30":[26,27,29,30],
    "31-36":[32,33,35,36]
  };
  return map[label] || [];
}

function pickFTLBlock(last2){
  if(last2.length<1) return null;
  const d1 = dsKeyLabel(dsRangeOf(last2[0]));
  const d2 = last2.length>=2 ? dsKeyLabel(dsRangeOf(last2[1])) : null;
  const all = ["1-6","7-12","13-18","19-24","25-30","31-36"];
  const idx = (x)=> all.indexOf(x);
  if(!d1) return null;
  if(d2 && idx(d2)!==-1){
    const i1 = idx(d1), i2 = idx(d2);
    const lo = Math.min(i1,i2), hi = Math.max(i1,i2);
    // can we choose 4 adjacent including both?
    // choose window of 4 containing [lo,hi]
    if(hi-lo <= 3){
      let start = Math.max(0, hi-3);
      start = Math.min(start, lo);
      start = Math.min(start, all.length-4);
      return all.slice(start, start+4);
    }
  }
  // fallback: include most recent d1, center window around it
  const i = idx(d1);
  const start = Math.max(0, Math.min(all.length-4, i-1));
  return all.slice(start,start+4);
}

function scoreMoonDance(vals){
  const last15 = vals.slice(0,15);
  if(last15.length<15) return {score:0, why:"Need 15 spins."};
  const {counts, picks} = leastTwoStreetsPerDozen(last15);
  // score higher when depletion is strong: lowest streets very low (0-1 hits)
  const lows = [];
  [1,2,3].forEach(d=>{
    picks[d].forEach(within=>{
      lows.push(counts[d][within-1]);
    });
  });
  const avgLow = lows.reduce((a,b)=>a+b,0)/lows.length;
  const zeros = lows.filter(x=>x===0).length;
  let score = 70 + zeros*6 + Math.max(0, (2-avgLow))*10; // heuristic
  score = Math.max(0, Math.min(99, Math.round(score)));
  const nums = moonDanceNumbers(last15);
  return {score, why:`Least-hit streets identified per dozen (18-number coverage).`, numbers: nums};
}

function scoreTrinity(vals){
  const last15 = vals.slice(0,15);
  if(last15.length<15) return {score:0, why:"Need 15 spins."};
  const dsHits = last15.filter(n=>{
    if(n==="00"||n===0) return false;
    const v = Number(n);
    return v>=1 && v<=12; // DS 1-12 coverage proxy
  }).length;
  const cornerSet = new Set([13,14,15,17,18,19,20,21,23,24,25,26,27,29,30,31,32,33,35,36]);
  const cornerHits = last15.filter(n=> n!=="00" && cornerSet.has(Number(n))).length;
  let score = 68 + Math.min(20, cornerHits)*1.0 + Math.max(0, 6-dsHits)*3; // favors corner action + DS cold
  score = Math.max(0, Math.min(99, Math.round(score)));
  return {score, why:"Corner density + DS 1–12 state supports Trinity cadence.", numbers: Array.from(cornerSet).sort((a,b)=>a-b)};
}

function scoreOppSeg(vals){
  const last15 = vals.slice(0,15);
  if(last15.length<15) return {score:0, why:"Need 15 spins."};
  const counts = {A:0,B:0,C:0,D:0};
  last15.forEach(n=>{
    const s = segmentOf(n);
    if(s) counts[s]+=1;
  });
  // tie-break A->B->C->D
  let hottest = "A";
  SEG_ORDER.forEach(seg=>{
    if(counts[seg] > counts[hottest]) hottest = seg;
  });
  const hotCount = counts[hottest];
  let score = 55 + Math.max(0, hotCount-4)*10; // 5->65, 6->75, 7->85...
  if(hotCount>=6) score += 10;
  score = Math.max(0, Math.min(99, Math.round(score)));
  const betSeg = oppositeSeg(hottest);
  return {score, why:`Hottest segment ${hottest}=${hotCount}/15 → bet opposite ${betSeg}.`, numbers: segNumbers(betSeg)};
}

function scoreFTL(vals){
  if(vals.length<3) return {score:0, why:"Need at least 3 spins."};
  const last2 = vals.slice(0,2);
  const block = pickFTLBlock(last2);
  if(!block) return {score:0, why:"No DS mapping."};
  // score higher if last 6 contains hits inside block
  const last15 = vals.slice(0,15);
  const inBlock = (n)=>{
    if(n==="00"||n===0) return false;
    const v = Number(n);
    for(const lbl of block){
      const [a,b]=lbl.split("-").map(Number);
      if(v>=a && v<=b) return true;
    }
    return false;
  };
  const hit6 = last15.slice(0,6).filter(inBlock).length;
  const hit15 = last15.filter(inBlock).length;
  let score = 60 + hit6*5 + Math.max(0, hit15-6)*2;
  score = Math.max(0, Math.min(95, Math.round(score)));
  // numbers to bet: all DS numbers plus corners mapped per DS
  const nums = [];
  block.forEach(lbl=>{
    const [a,b]=lbl.split("-").map(Number);
    for(let x=a;x<=b;x++) nums.push(x);
    nums.push(...cornersForDSRange(lbl));
  });
  const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);
  return {score, why:`Follow last 2 spins → DS block ${block.join(", ")} (locked until loss).`, block, numbers: uniq};
}

function scoreJunkoHot(vals){
  const last15 = vals.slice(0,15);
  const c15 = counts(last15);
  const qMax = Math.max(c15.gn,c15.ho,c15.lo,c15.m);
  let score = 55 + Math.max(0, qMax-4)*10; // 5->65,6->75,7->85
  if(qMax>=6) score += 10;
  score = Math.max(0, Math.min(95, Math.round(score)));
  return {score, why:`Junko quadrant momentum: max ${qMax}/15.`, numbers: []};
}

function scoreJunko10ToWin(windowN, vals) {
  const w = lastN(history, win);
  if (w.length < 15) return { score: 0, label: "Need 15+", detail: "Warmup" };

  const lookback = 8;
  const tail = w.slice(-lookback).map(n => normalizeSpin(n));
  const sets = {
    GN: new Set([99,0,1,2,9,10,13,14,27,28]),
    HO: new Set([24,25,26,29,30,33,34,35,36]),
    LO: new Set([3,4,8,11,12,15,16,22,23]),
    M:  new Set([5,6,7,17,18,19,20,21,31,32]),
  };

  const counts = { GN:0, HO:0, LO:0, M:0 };
  for (const x of tail) {
    for (const k of Object.keys(sets)) {
      if (sets[k].has(x)) { counts[k]++; break; }
    }
  }

  const zeros = Object.keys(counts).filter(k => counts[k] === 0);
  if (!zeros.length) return { score: 58, label: "No drought", detail: "Need a missing quadrant in last 8" };

  const nonzero = Object.keys(counts).filter(k => counts[k] > 0).map(k => counts[k]);
  let balanced = false;
  if (nonzero.length) {
    const mx = Math.max(...nonzero), mn = Math.min(...nonzero);
    balanced = (mx - mn) <= 1;
  }

  const order = ["GN","HO","LO","M"];
  const missing = order.find(k => zeros.includes(k)) || zeros[0];

  const score = balanced ? 88 : 76;
  return { score, label: `Missing ${missing}`, detail: `Counts(last 8): GN ${counts.GN} | HO ${counts.HO} | LO ${counts.LO} | M ${counts.M}` };
}



function scoreSlowSteady(vals){
  const last15 = vals.slice(0,15);
  const c15 = counts(last15);
  const dozMax = Math.max(c15.d1,c15.d2,c15.d3);
  const colMax = Math.max(c15.c1,c15.c2,c15.c3);
  let score = 50 + Math.max(dozMax, colMax)*4;
  score = Math.max(0, Math.min(90, Math.round(score)));
  return {score, why:`Structural bias: Dozen max ${dozMax}/15, Column max ${colMax}/15.`, numbers: []};
}


function scoreHydraColumns(vals){
  // Heuristic: strong and persistent column imbalance favors column-based Hydra.
  const cols = vals.columns.counts; // [c1,c2,c3]
  const sorted = [...cols].sort((a,b)=>b-a);
  const gap = sorted[0]-sorted[2];
  const score = Math.min(98, 70 + gap*8);
  const why = gap >= 3 ? `Column imbalance detected (gap=${gap} in last ${vals.window}).` : `Mild column skew (gap=${gap}); treat as backup.`;
  // Suggest betting the 2 cold columns (fixed) as Tier 1 focus.
  const coldIdx = cols.map((v,i)=>({v,i})).sort((a,b)=>a.v-b.v).slice(0,2).map(x=>x.i+1);
  const numbers = coldIdx.includes(1)&&coldIdx.includes(2) ? "C1+C2" :
                  coldIdx.includes(1)&&coldIdx.includes(3) ? "C1+C3" : "C2+C3";
  return {score, why, numbers:`Tier1 focus: ${numbers} (columns)`};
}

function scoreHydraHybrid(vals){
  // Mode select: columns vs dozens based on whichever has clearer imbalance.
  const cols = vals.columns.counts;
  const doz = vals.dozens.counts;
  const colGap = Math.max(...cols)-Math.min(...cols);
  const dozGap = Math.max(...doz)-Math.min(...doz);
  const gap = Math.max(colGap, dozGap);
  const score = Math.min(99, 72 + gap*9);
  const mode = (colGap >= dozGap) ? "Columns" : "Dozens";
  const why = gap >= 3 ? `Clear ${mode.toLowerCase()} imbalance (gap=${gap} in last ${vals.window}); hybrid mode selects ${mode}.` :
                        `No clear imbalance (gap=${gap}); use only if you want disciplined structure.`;
  return {score, why, numbers:`Mode: ${mode} (Tier1), then T1.5–T4 ladder`};
}

function scoreCornersDSTight(vals){
  // Heuristic: if last-15 shows clustering inside a contiguous DS block, tightened DS+corners can be viable.
  const dsCounts = vals.doubleStreets.perDozenFlat; // array of 12 DS buckets, if provided
  if(!dsCounts){
    return {score:78, why:"DS distribution unavailable; treat as conditional.", numbers:"4 adjacent DS block + recovery corners"};
  }
  const max = Math.max(...dsCounts);
  const score = Math.min(96, 68 + max*5);
  const why = `Top DS bucket count=${max} in last ${vals.window}; tightened DS lock can exploit local clustering.`;
  return {score, why, numbers:"4 DS @ $2×u; corners recovery after 3 DS misses; ramp green hedge"};
}

function scoreDisappearingStreets(vals){
  // Comp-builder / low confidence cash: prefer when streets are repeating.
  const score = 74;
  const why = "Comp builder; use only if street repeat behavior is obvious.";
  return {score, why, numbers:"Situational street coverage (comp mode)"};
}




function scoreDBCDS(vals){
  // Dirty Bird — Cold Dozen Switch (DB-CDS)
  // Uses last 15 NON-GREEN spins (0 and 00/99 ignored).
  const window = [];
  for(const v of vals){
    const n = normSpin(v);
    if(n===null) continue;
    if(isGreen(n)) continue;
    if(typeof n==="number" && n>=1 && n<=36) window.push(n);
    if(window.length>=15) break;
  }
  if(window.length < 15) return {score:0, why:"Need 15 non-green spins.", dozen:null, exclude:[], numbers:[]};

  const counts = {D1:0,D2:0,D3:0};
  for(const n of window){
    if(n<=12) counts.D1++;
    else if(n<=24) counts.D2++;
    else counts.D3++;
  }
  const tieOrder = ["D1","D2","D3"];
  let cold="D1", hot="D1";
  let minC=Infinity, maxC=-Infinity;
  for(const dz of tieOrder){
    const c = counts[dz];
    if(c<minC){minC=c; cold=dz;}
    if(c>maxC){maxC=c; hot=dz;}
  }
  const coldHits = counts[cold];
  const mode = (coldHits<=3) ? "SWITCH" : "COLD_DOZEN";
  const dz = (mode==="SWITCH") ? hot : cold;

  const min = (dz==="D1")?1:(dz==="D2")?13:25;
  const max = (dz==="D1")?12:(dz==="D2")?24:36;
  const numCounts = {};
  for(let i=min;i<=max;i++) numCounts[i]=0;
  for(const n of window){
    if(n>=min && n<=max) numCounts[n] = (numCounts[n]||0)+1;
  }
  const entries = Object.entries(numCounts).map(([k,v])=>({n:+k,c:v}));
  let exclude=[];
  if(mode==="COLD_DOZEN"){
    entries.sort((a,b)=>(a.c-b.c)||(a.n-b.n));
    exclude=[entries[0].n, entries[1].n];
  }else{
    entries.sort((a,b)=>(b.c-a.c)||(a.n-b.n));
    exclude=[entries[0].n, entries[1].n];
  }
  const numbers=[];
  for(let i=min;i<=max;i++) if(!exclude.includes(i)) numbers.push(i);

  let score = 0;
  if(mode==="SWITCH") score = 90;
  else score = Math.max(80, Math.min(92, 80 + Math.max(0,(6-coldHits))*2));

  const why = (mode==="SWITCH")
    ? `DB-CDS SWITCH: bet ${dz}, leave off ${exclude[0]},${exclude[1]}`
    : `DB-CDS COLD: bet ${dz}, leave off ${exclude[0]},${exclude[1]}`;

  return {score, why, mode, dozen:dz, exclude, numbers, dozenCounts:counts, coldestDozen:cold, coldestHits:coldHits};
}

function scoreStrategies(vals) {
  const plays = [];
  const add = (name, score, why, extra={}) => plays.push({name, score, why, ...extra});

  // Base COMP always present
  add("6 Diamonds + 0/00 (Primary)", 70, "Default COMP coverage / survivability.");

  const md = scoreMoonDance(vals); add("Moon Dance 2S/Dozen (Junko Base)", md.score, md.why, {numbers: md.numbers});
  
const db = scoreDBCDS(vals); add("Dirty Bird — Cold Dozen Switch (DB-CDS)", db.score, db.why, {numbers: db.numbers, dozen: db.dozen, exclude: db.exclude, mode: db.mode});
const tr = scoreTrinity(vals); add("Trinity–Junko v2", tr.score, tr.why, {numbers: tr.numbers});
  const os = scoreOppSeg(vals); add("Opposite-Segment Contrarian (Option 1)", os.score, os.why, {numbers: os.numbers});
  const ftl = scoreFTL(vals); add("Corners + Double Streets (Follow the Leader)", ftl.score, ftl.why, {numbers: ftl.numbers, block: ftl.block});
  const jh = scoreJunkoHot(vals); add("Junko Hot (Quadrant Momentum)", jh.score, jh.why);
  const j10 = scoreJunko10ToWin(windowN, vals); add("Junko 10 to Win (Quadrant-Gated)", j10.score, j10.label);
  const ss = scoreSlowSteady(vals); add("Slow & Steady (Structural Bias)", ss.score, ss.why);

// New rotation strategies
const hc = scoreHydraColumns(vals); add("Hydra v1.5B — Columns (Fixed)", hc.score, hc.why, {numbers: hc.numbers});
const hh = scoreHydraHybrid(vals); add("Hydra v1.5B — Hybrid Switch", hh.score, hh.why, {numbers: hh.numbers});
const ct = scoreCornersDSTight(vals); add("Corners + DS Tightened Variant", ct.score, ct.why, {numbers: ct.numbers});
const ds = scoreDisappearingStreets(vals); add("Disappearing Streets (Comp Builder)", ds.score, ds.why, {numbers: ds.numbers});
// Sort by score for display
  plays.sort((a,b)=>b.score-a.score);
  const top3 = plays.slice(0,3);

  // Determine active recommendation with CASH priority rule
  let primary = top3[0] || {name:"Sit out", score:1, why:"No clear edge."};

  // CASH gate: choose among CASH-eligible (score>=85) using priority order.
  const eligible = plays.filter(p => p.score >= 85 && CASH_PRIORITY.includes(p.name));
  let chosenCash = null;
  if(eligible.length){
    for(const nm of CASH_PRIORITY){
      const p = eligible.find(x => x.name === nm);
      if(p){ chosenCash = p; break; }
    }
  }
  // If chosenCash exists, it becomes primary only if it's also #1 overall (per operating spec).
  if(chosenCash && plays[0] && plays[0].name === chosenCash.name){
    primary = chosenCash;
    primary.mode = "CASH";
  } else {
    primary.mode = "COMP";
    // If table unclear/no data, stay COMP.
    if(vals.length < 10){
      primary = {name:"Sit out", score:1, why:"Log at least 10 spins for trend signals.", mode:"COMP"};
    } else if(primary.name !== "6 Diamonds + 0/00 (Primary)" && primary.score < 85){
      primary = plays.find(p=>p.name==="6 Diamonds + 0/00 (Primary)") || primary;
      primary.mode = "COMP";
    }
  }

  // Table state simple
  const rn = repeatNumberInfo(vals, 5);
  const rs3 = repeatStreetInfo(vals, 3);
  let state = "Flat / Choppy";
  if(rn.flag || rs3.flag) state = "Repeat-Heavy";
  else {
    const w15 = vals.slice(0,15);
    const c15 = counts(w15);
    const colMax15 = Math.max(c15.c1,c15.c2,c15.c3);
    const dozMax15 = Math.max(c15.d1,c15.d2,c15.d3);
    if(colMax15 >= 7 || dozMax15 >= 7) state = "Concentrated";
  }

  return {state, plays: top3, primary};
}

function render() {
    $("winLabel").textContent = "Last " + windowN;
    $("spinCount").textContent = String(spins.length);
    $("sessionCount").textContent = String(spins.filter(x => x.s===sessionId).length);

    const recent = windowValues();
    $("greenCount").textContent = String(recent.filter(isGreen).length);

    const cts = counts(recent);
    $("cols").textContent = `${cts.c1} / ${cts.c2} / ${cts.c3}`;
    $("doz").textContent  = `${cts.d1} / ${cts.d2} / ${cts.d3}`;

    const dsc = dsCounts(recent);
    $("ds").textContent = `D1 ${dsc.d1[0]}/${dsc.d1[1]}/${dsc.d1[2]} | D2 ${dsc.d2[0]}/${dsc.d2[1]}/${dsc.d2[2]} | D3 ${dsc.d3[0]}/${dsc.d3[1]}/${dsc.d3[2]}`;

    $("rb").textContent   = `${cts.red} / ${cts.black}`;
    $("hl").textContent   = `${cts.high} / ${cts.low}`;
    $("eo").textContent   = `${cts.even} / ${cts.odd}`;
    $("junko").textContent= `GN ${cts.gn} | HO ${cts.ho} | LO ${cts.lo} | M ${cts.m}`;

    $("lastList").value = spins.slice(0,20).map(x => (x.n==="00"?"00":String(x.n))).join(", ");

    let scored = null;
    const history = spins.slice().reverse().map(s=> (s.n==='00'?99:s.n));
    scored = scoreStrategies(recent, history);

    // ---- Table state / repeats / hydra cold ----
  try{
    const ts = computeTableState(history, 15);
    $("tableState").textContent = ts;
    $("tableStateDetail").textContent = "";
    const rep = repeatNumberInfo(history, 20);
    $("repeatsInfo").textContent = rep ? `Repeats (20): ${rep}` : "";
    const srep = repeatStreetInfo(history, 20);
    $("streetRepeatsInfo").textContent = srep ? `Streets (20): ${srep}` : "";
    const cold4 = computeHydraColdNumbers(history);
    $("hydraCold4").textContent = cold4 && cold4.length ? `Hydra cold 4: ${cold4.map(x=>`${x.n===99?"00":x.n}(${x.age})`).join(" • ")}` : "";
    $("sinceGreen").textContent = `Since green: ${computeSinceGreen(history)}`;
  }catch(e){}
$("recommend").textContent = `${scored.primary.mode} — ${scored.primary.name}`;
    $("reason").textContent = scored.primary.why || "—";
    $("state").textContent = scored.state;
    $("state2").textContent = `Window: last ${windowN} • Session: ${sessionId}`;

    // Top plays cards
    const topPlays = $("topPlays");
    topPlays.innerHTML = "";
    scored.plays.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "playcard";
      div.innerHTML = `
        <div class="playhdr">
          <div>
            <div style="font-weight:900">${idx+1}. ${p.mode} — ${p.name}</div>
            <div class="small">${(p.why||"—").replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>
          </div>
          <div class="tag">${p.mode} • ${p.score}</div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn small" data-exp="${p.name}">Explain</button>
        </div>
      `;
      topPlays.appendChild(div);
    });
    [...topPlays.querySelectorAll("button[data-exp]")].forEach(b => {
      b.addEventListener("click", () => showExplain(b.getAttribute("data-exp")));
    });

    // Primary explain button
    const pb = $("primaryExplainBtn");
    if(STRATEGY_DETAILS[scored.primary.name] && scored.primary.name !== "Sit out") {
      pb.style.display = "inline-block";
      pb.onclick = () => showExplain(scored.primary.name);
    } else {
      pb.style.display = "none";
      pb.onclick = null;
    }
  }

  // UI wiring
  $("undoBtn").addEventListener("click", undo);
  $("clearBtn").addEventListener("click", clearAll);
  $("use15Btn").addEventListener("click", () => { windowN=15; save(); render(); });
  $("use10Btn").addEventListener("click", () => { windowN=10; save(); render(); });
  $("use20Btn").addEventListener("click", () => { windowN=20; save(); render(); });
  $("newSessionBtn").addEventListener("click", newSession);

  $("addManualBtn").addEventListener("click", () => {
    const raw = ($("manualInput").value||"").trim();
    if(!raw) return;
    if(raw === "00") addSpin("00");
    else if(/^[0-9]+$/.test(raw)) addSpin(Number(raw));
    $("manualInput").value = "";
  });
  $("manualInput").addEventListener("keydown", (e) => {
    if(e.key === "Enter") {
      e.preventDefault();
      $("addManualBtn").click();
    }
  });

  $("casinoInput").addEventListener("input", save);

  $("copyCsvBtn").addEventListener("click", copyCsv);
  $("downloadCsvBtn").addEventListener("click", downloadCsv);

  $("importBtn").addEventListener("click", () => {
    const res = importCsvText($("importArea").value);
    $("importStatus").textContent = res.msg;
  });
  $("clearImportBtn").addEventListener("click", () => {
    $("importArea").value = "";
    $("importStatus").textContent = "";
  });

    // ---------------- Wheel View (Last 20) ----------------
    const WHEEL = [0,28,9,26,30,11,7,20,32,17,5,22,34,15,3,24,36,13,1,"00",27,10,25,29,12,8,19,31,18,6,21,33,16,4,23,35,14,2];

    function numLabel(n){ return (n === "00") ? "00" : String(n); }

    function pocketColor(n){
      if(n === 0 || n === "00") return "rgba(80, 220, 160, 0.95)"; // green
      const v = Number(n);
      return (RED[v] ? "rgba(255, 92, 92, 0.95)" : "rgba(70, 140, 255, 0.95)"); // red / black-blue
    }

    function drawWheelHistogram(lastN=20){
      const canvas = document.getElementById("wheelCanvas");
      if(!canvas) return;
      const ctx = canvas.getContext("2d");

      // HiDPI crispness
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || 420;
      const size = Math.min(cssW, 520);
      canvas.style.height = size + "px";
      canvas.style.width  = size + "px";
      canvas.width  = Math.floor(size * dpr);
      canvas.height = Math.floor(size * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      ctx.clearRect(0,0,size,size);

      const cx = size/2, cy = size/2;
      const outerR = (size/2) - 16;
      const ringR1 = outerR - 46;
      const innerR = 54;
      const barLen = 10;
      const barGap = 2;
      const step = (Math.PI*2)/WHEEL.length;
      const start = -Math.PI/2;

      // count last N spins (spins is newest-first)
      const slice = spins.slice(0, lastN);
      const cts = {};
      for(const x of slice){
        const k = (x.n === "00") ? "00" : String(x.n);
        cts[k] = (cts[k]||0) + 1;
      }
      let maxC = 0;
      for(const n of WHEEL) maxC = Math.max(maxC, cts[numLabel(n)]||0);

      // background rings
      ctx.beginPath();
      ctx.arc(cx,cy,outerR,0,Math.PI*2);
      ctx.fillStyle="rgba(255,255,255,0.04)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(cx,cy,ringR1,0,Math.PI*2);
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.fill();

      for(let k=0;k<WHEEL.length;k++){
        const a0 = start + k*step;
        const a1 = a0 + step;

        ctx.beginPath();
        ctx.moveTo(cx + ringR1*Math.cos(a0), cy + ringR1*Math.sin(a0));
        ctx.arc(cx,cy,ringR1,a0,a1);
        ctx.lineTo(cx + outerR*Math.cos(a1), cy + outerR*Math.sin(a1));
        ctx.arc(cx,cy,outerR,a1,a0,true);
        ctx.closePath();

        ctx.fillStyle="rgba(255,255,255,0.02)";
        ctx.fill();
        ctx.strokeStyle="rgba(255,255,255,0.06)";
        ctx.lineWidth=1;
        ctx.stroke();

        const n = WHEEL[k];
        const key = numLabel(n);
        const c = cts[key]||0;

        if(c>0){
          const aw = step*0.72;
          const mid = (a0+a1)/2;
          for(let s=0;s<c;s++){
            const r1 = innerR + s*(barLen+barGap);
            const r2 = r1 + barLen;
            ctx.beginPath();
            ctx.moveTo(cx + r1*Math.cos(mid-aw/2), cy + r1*Math.sin(mid-aw/2));
            ctx.arc(cx,cy,r1, mid-aw/2, mid+aw/2);
            ctx.lineTo(cx + r2*Math.cos(mid+aw/2), cy + r2*Math.sin(mid+aw/2));
            ctx.arc(cx,cy,r2, mid+aw/2, mid-aw/2, true);
            ctx.closePath();

            ctx.fillStyle = pocketColor(key);
            ctx.globalAlpha = 0.25 + 0.75*((s+1)/Math.max(1,maxC));
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        // label
        const midA = (a0+a1)/2;
        const tx = cx + (outerR-18)*Math.cos(midA);
        const ty = cy + (outerR-18)*Math.sin(midA);
        ctx.save();
        ctx.translate(tx,ty);
        ctx.rotate(midA + Math.PI/2);
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
        ctx.fillStyle="rgba(255,255,255,0.85)";
        ctx.fillText(key, 0, 0);
        ctx.restore();

        // count badge
        if(c>0){
          const bx = cx + (ringR1+18)*Math.cos(midA);
          const by = cy + (ringR1+18)*Math.sin(midA);
          ctx.beginPath();
          ctx.arc(bx,by,10,0,Math.PI*2);
          ctx.fillStyle="rgba(0,0,0,0.35)";
          ctx.fill();
          ctx.strokeStyle="rgba(255,255,255,0.12)";
          ctx.stroke();

          ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
          ctx.fillStyle="rgba(255,255,255,0.95)";
          ctx.textAlign="center";
          ctx.textBaseline="middle";
          ctx.fillText(String(c), bx, by);
        }
      }

      // center label
      ctx.beginPath();
      ctx.arc(cx,cy,innerR-14,0,Math.PI*2);
      ctx.fillStyle="rgba(0,0,0,0.30)";
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,0.10)";
      ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="14px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText("LAST " + lastN, cx, cy-10);
      ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
      ctx.fillStyle="rgba(255,255,255,0.70)";
      ctx.fillText("hit histogram", cx, cy+10);
    }

    function openWheelModal(){
      const m = document.getElementById("wheelModal");
      if(!m) return;
      m.style.display = "flex";
      drawWheelHistogram(20);
    }
    function closeWheelModal(){
      const m = document.getElementById("wheelModal");
      if(m) m.style.display = "none";
    }

    const wheelBtn = document.getElementById("wheelViewBtn");
    if(wheelBtn) wheelBtn.addEventListener("click", openWheelModal);

    const wheelClose = document.getElementById("wheelCloseBtn");
    if(wheelClose) wheelClose.addEventListener("click", closeWheelModal);

    const wheelModal = document.getElementById("wheelModal");
    if(wheelModal) wheelModal.addEventListener("click", (e)=>{ if(e.target && e.target.id==="wheelModal") closeWheelModal(); });

    window.addEventListener("resize", ()=>{ if(wheelModal && wheelModal.style.display !== "none") drawWheelHistogram(20); });
  load();
  buildKeypad();
  
  if(trendDismissBtn){
    trendDismissBtn.onclick = function(){ if(trendAlert) trendAlert.style.display="none"; };
  }
render();
});

  function streetKey(n){
    // streets are 1-3,4-6,...,34-36; return like "1-3"
    if(n===0||n===99) return null;
    const start = Math.floor((n-1)/3)*3 + 1;
    return `${start}-${start+2}`;
  }

  function repeatNumberInfo(history, N=20){
    const w = history.slice(-N);
    const counts = new Map();
    for(const x of w){ counts.set(x, (counts.get(x)||0)+1); }
    const reps = [...counts.entries()].filter(([n,c])=>c>=2).sort((a,b)=>b[1]-a[1] || a[0]-b[0]);
    if(!reps.length) return "";
    return reps.slice(0,6).map(([n,c])=>`${n===99?"00":n}×${c}`).join(" • ");
  }

  function repeatStreetInfo(history, N=20){
    const w = history.slice(-N);
    const counts = new Map();
    for(const x of w){
      const k = streetKey(x);
      if(!k) continue;
      counts.set(k, (counts.get(k)||0)+1);
    }
    const reps = [...counts.entries()].filter(([k,c])=>c>=3).sort((a,b)=>b[1]-a[1] || a[0].localeCompare(b[0]));
    if(!reps.length) return "";
    return reps.slice(0,4).map(([k,c])=>`${k}×${c}`).join(" • ");
  }

  function computeHydraColdNumbers(history){
    // "age" = spins since last appearance (0 means just hit on latest spin)
    const all = [];
    const maxN = 37; // 0-36 plus 00(99)
    const lastIdx = new Map();
    for(let i=0;i<history.length;i++){
      lastIdx.set(history[i], i);
    }
    const L = history.length;
    const nums = [];
    for(let n=0;n<=36;n++) nums.push(n);
    nums.push(99);
    for(const n of nums){
      const idx = lastIdx.has(n)? lastIdx.get(n) : -1;
      const age = idx===-1 ? L : (L-1-idx);
      all.push({n, age});
    }
    all.sort((a,b)=>b.age-a.age || (a.n===99?37:a.n)-(b.n===99?37:b.n));
    return all.slice(0,4);
  }

  function computeSinceGreen(history){
    // count spins since last 0/00
    for(let i=history.length-1, age=0; i>=0; i--, age++){
      if(history[i]===0 || history[i]===99) return age;
    }
    return history.length;
  }

  function computeTableState(history, N=15){
    if(history.length < N) return "WARMUP";
    const w = history.slice(-N);
    const seen = new Set();
    let repeatCount = 0;
    for(const x of w){
      if(seen.has(x)) repeatCount++;
      seen.add(x);
    }
    const col = {1:0,2:0,3:0};
    const doz = {1:0,2:0,3:0};
    for(const x of w){
      if(x===0||x===99) continue;
      col[((x-1)%3)+1]++; 
      doz[Math.floor((x-1)/12)+1]++;
    }
    const colGap = Math.max(col[1],col[2],col[3]) - Math.min(col[1],col[2],col[3]);
    const dozGap = Math.max(doz[1],doz[2],doz[3]) - Math.min(doz[1],doz[2],doz[3]);
    const structured = (colGap>=3) || (dozGap>=3);
    const choppy = repeatCount >= 4; // heuristic
    if(choppy && structured) return "CHOPPY + STRUCTURED";
    if(structured) return "STRUCTURED";
    if(choppy) return "CHOPPY";
    return "FLAT";
  }

</script>
</body>
</html,
  "CASH — Junko 10 to Win (Quadrant-Gated)": {
    type: "CASH",
    title: "Junko 10 to Win (Quadrant-Gated)",
    bullets: [
      "Warmup: observe 15 spins, no bets.",
      "Trigger (last 8): at least one quadrant has 0 hits AND the others are balanced (max-min ≤ 1).",
      "Bet the missing quadrant with per-number units u = 1,1,2,3,5 then +1 each additional miss.",
      "Remove any hit number from that quadrant; reset u=1 on a hit."
    ],
    howTo: [
      "Sets (American; 00 encoded as 99):",
      "GN=(99, 0, 1, 2, 9, 10, 13, 14, 27, 28)",
      "HO=(24, 25, 26, 29, 30, 33, 34, 35, 36)",
      "LO=(3, 4, 8, 11, 12, 15, 16, 22, 23)",
      "M =(5, 6, 7, 17, 18, 19, 20, 21, 31, 32)",
      "",
      "When triggered: bet ALL remaining numbers in the missing quadrant at unit u ($ per number).",
      "Progression: u sequence 1,1,2,3,5; after 5th miss, u = 6,7,8... (+1 each miss).",
      "On hit: remove that number from the set; reset u=1.",
      "Exit: cashout +$100; stop-loss -$300; guardrail: no bet if worst-case loss would breach stop-loss."
    ]
  }>