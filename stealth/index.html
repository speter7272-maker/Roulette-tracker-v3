<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stealth Text Mode • v0.8 • Opposite Segment Added</title>
  <style>
    :root{color-scheme:dark; --bg:#070b14; --panel:#0f1a2e; --chip:#111c33; --border:#1f2a44; --txt:#e5e7eb; --muted:#94a3b8;}
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#060911,#070b14 40%,#060911);color:var(--txt)}
    .wrap{max-width:760px;margin:0 auto;min-height:100vh;display:flex;flex-direction:column}
    .topbar{padding:12px 14px 10px;border-bottom:1px solid rgba(255,255,255,.06);background:rgba(8,12,20,.6);backdrop-filter:blur(10px);position:sticky;top:0;z-index:3}
    .name{font-weight:800;font-size:18px;line-height:1}
    .sub{margin-top:6px;color:var(--muted);font-size:12px}
    .chat{flex:1;padding:14px;display:flex;flex-direction:column;gap:10px}
    .row{display:flex}
    .row.me{justify-content:flex-end}
    .bubble{max-width:min(560px,92%);padding:10px 12px;border-radius:16px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);box-shadow:0 10px 28px rgba(0,0,0,.25)}
    .row.me .bubble{background:rgba(59,130,246,.22);border-color:rgba(59,130,246,.28)}
    .hdr{display:flex;gap:8px;align-items:center;margin-bottom:6px}
    .tag{font-size:11px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);font-size:11px;color:var(--muted)}
    .b{font-weight:800}
    .small{font-size:12px;line-height:1.35;color:var(--txt)}
    .muted{color:var(--muted)}
    .kv{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    .card{padding:10px;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.04)}
    .k{font-size:11px;color:var(--muted)}
    .v{font-size:16px;font-weight:900;margin-top:2px}
    .v.mono{font-size:15px}
    .inputbar{padding:12px 14px;border-top:1px solid rgba(255,255,255,.06);background:rgba(8,12,20,.7);backdrop-filter:blur(10px);position:sticky;bottom:0}
    .hint{font-size:12px;color:var(--muted);margin-bottom:8px}
    .form{display:flex;gap:10px}
    input{flex:1;border-radius:16px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);color:var(--txt);padding:12px 12px;font-size:16px;outline:none}
    button{border-radius:16px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.08);color:var(--txt);padding:12px 14px;font-weight:800;font-size:16px}
    button:active{transform:translateY(1px)}
    a{color:inherit}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="name" id="contactName">Scott</div>
    <div class="sub" id="buildLine">Texting view • STEALTH TEXT MODE — v0.8 (Opposite Segment strategy added)</div>
  </div>

  <div class="chat" id="chat"></div>

  <div class="inputbar">
    <div class="hint" id="hint">
      Paste history as comma-separated numbers (example: <span class="mono">0,00,34,23,5,17</span>) then tap <b>Send</b>.
      Commands: <b>status</b>, <b>trend</b>, <b>explain</b>, <b>explain 2</b>, <b>wheel</b>, <b>export</b>, <b>offline</b>, <b>clear</b>.
    </div>
    <div class="form">
      <input id="msg" type="text" placeholder="Type a spin, a comma list, or a command…" autocomplete="off" autocapitalize="none" />
      <button id="send" type="button">Send</button>
    </div>
  </div>
</div>

<script>
(() => {
  const VERSION = "v0.8";
  const STORAGE_KEY = "roulette_stealth_v0_8";
  const RED = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  const BLACK = new Set([2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35]);

  // Junko quadrants
  const GN = new Set(["00",0,1,2,9,10,13,14,27,28]);
  const HO = new Set([24,25,26,29,30,33,34,35,36]);
  const LO = new Set([3,4,8,11,12,15,16,22,23]);
  const MID= new Set([5,6,7,17,18,19,20,21,31,32]);

  // Opposite-Segment Contrarian (stress test) segments (00 as "00")
  const SEG_A = new Set([13,1,"00",27,10,9,28,0,2,14]);
  const SEG_B = new Set([31,18,6,21,33,17,5,22,32,20]);
  const SEG_C = new Set([25,29,12,8,19,26,30,11,7]); // 9
  const SEG_D = new Set([36,24,3,15,34,35,23,4,16]); // 9
  const TIE_ORDER = ["A","B","C","D"];
  function segOf(n){
    const k = (n==="00") ? "00" : Number(n);
    if(SEG_A.has(k)) return "A";
    if(SEG_B.has(k)) return "B";
    if(SEG_C.has(k)) return "C";
    if(SEG_D.has(k)) return "D";
    return null;
  }
  function oppositeSeg(s){
    if(s==="A") return "C";
    if(s==="B") return "D";
    if(s==="C") return "A";
    if(s==="D") return "B";
    return null;
  }
  function segSet(s){
    if(s==="A") return SEG_A;
    if(s==="B") return SEG_B;
    if(s==="C") return SEG_C;
    if(s==="D") return SEG_D;
    return null;
  }

  let casino = "";
  let awaitingCasino = false;
  let spins = []; // newest-first; each {n,t,s}
  let sessionId = 1;
  let windowN = 15;

  const $ = (id) => document.getElementById(id);

  function now(){ return Date.now(); }

  function numToKey(x){
    if(x === "00") return "00";
    if(typeof x === "string" && x.trim() === "00") return "00";
    const v = Number(String(x).trim());
    if(!Number.isFinite(v)) return null;
    if(v === 0) return 0;
    if(v >= 1 && v <= 36) return v;
    return null;
  }

  function isGreen(n){ return (n === "00" || Number(n) === 0); }
  function isRed(n){ return (n !== "00" && RED.has(Number(n))); }
  function isBlack(n){ return (n !== "00" && BLACK.has(Number(n))); }
  function isHigh(n){ return (n !== "00" && Number(n) >= 19); }
  function isLow(n){ return (n !== "00" && Number(n) >= 1 && Number(n) <= 18); }
  function isEven(n){ return (n !== "00" && Number(n) !== 0 && Number(n)%2===0); }
  function isOdd(n){ return (n !== "00" && Number(n)%2===1); }

  function colOf(n){
    if(n==="00" || n===0) return null;
    const v = Number(n);
    if(!(v>=1 && v<=36)) return null;
    const r = v % 3;
    return r===1?1:(r===2?2:3);
  }
  function dozenOf(n){
    if(n==="00" || n===0) return null;
    const v = Number(n);
    if(!(v>=1 && v<=36)) return null;
    return v<=12?1:(v<=24?2:3);
  }
  function streetId(n){
    if(n==="00" || n===0) return null;
    const v = Number(n);
    if(!(v>=1 && v<=36)) return null;
    return Math.floor((v-1)/3)+1; // 1..12
  }
  function dsKey(n){
    if(n==="00" || n===0) return null;
    const v = Number(n);
    if(!(v>=1 && v<=36)) return null;
    const d = v<=12?1:(v<=24?2:3);
    const base = (d-1)*12;
    const a = base+1, b = base+4, c = base+7;
    if(v>=a && v<=a+5) return {d, i:1};
    if(v>=b && v<=b+5) return {d, i:2};
    if(v>=c && v<=c+5) return {d, i:3};
    return {d, i:2};
  }

  function junkoBucket(n){
    const k = (n==="00") ? "00" : Number(n);
    if(GN.has(k)) return "GN";
    if(HO.has(k)) return "HO";
    if(LO.has(k)) return "LO";
    if(MID.has(k)) return "M";
    return null;
  }

  function counts(vals){
    const c = {c1:0,c2:0,c3:0,d1:0,d2:0,d3:0,red:0,black:0,high:0,low:0,even:0,odd:0,gn:0,ho:0,lo:0,m:0,green:0};
    vals.forEach(n=>{
      if(isGreen(n)) c.green++;
      const col = colOf(n); if(col===1)c.c1++; if(col===2)c.c2++; if(col===3)c.c3++;
      const d = dozenOf(n); if(d===1)c.d1++; if(d===2)c.d2++; if(d===3)c.d3++;
      if(isRed(n)) c.red++;
      if(isBlack(n)) c.black++;
      if(isHigh(n)) c.high++;
      if(isLow(n)) c.low++;
      if(isEven(n)) c.even++;
      if(isOdd(n)) c.odd++;
      const jb = junkoBucket(n);
      if(jb==="GN") c.gn++;
      if(jb==="HO") c.ho++;
      if(jb==="LO") c.lo++;
      if(jb==="M") c.m++;
    });
    return c;
  }
  function dsCounts(vals){
    const out = {d1:[0,0,0], d2:[0,0,0], d3:[0,0,0]};
    vals.forEach(n=>{
      const k = dsKey(n);
      if(!k) return;
      const arr = (k.d===1?out.d1:(k.d===2?out.d2:out.d3));
      arr[k.i-1]+=1;
    });
    return out;
  }

  function repeatInfo(vals, lookback){
    const newest = vals[0];
    if(vals.length<2) return {num:false, street:false, ds:false, why:"—"};
    // number repeat
    let numRep=false;
    for(let i=1;i<Math.min(vals.length, lookback+1); i++){
      if(vals[i]===newest){ numRep=true; break; }
    }
    // street repeat
    const s0 = streetId(newest);
    let streetRep=false;
    if(s0){
      for(let i=1;i<Math.min(vals.length, lookback+1); i++){
        const si = streetId(vals[i]);
        if(si && si===s0){ streetRep=true; break; }
      }
    }
    // double-street repeat
    const d0 = dsKey(newest);
    let dsRep=false;
    if(d0){
      for(let i=1;i<Math.min(vals.length, lookback+1); i++){
        const di = dsKey(vals[i]);
        if(di && di.d===d0.d && di.i===d0.i){ dsRep=true; break; }
      }
    }
    return {num:numRep, street:streetRep, ds:dsRep};
  }

  function pushBubble(text, me=false, html=false){
    const chat = $("chat");
    const row = document.createElement("div");
    row.className = "row" + (me ? " me" : "");
    const b = document.createElement("div");
    b.className = "bubble";
    if(html) b.innerHTML = text;
    else b.textContent = text;
    row.appendChild(b);
    chat.appendChild(row);
    // scroll
    requestAnimationFrame(()=>{ window.scrollTo(0, document.body.scrollHeight); });
  }

  function save(){
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify({casino, awaitingCasino, spins, sessionId, windowN}));
    }catch(_){}
  }
  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const o = JSON.parse(raw);
      casino = typeof o.casino==="string" ? o.casino : "";
      awaitingCasino = !!o.awaitingCasino;
      if(Array.isArray(o.spins)){
        spins = o.spins.map(x => ({n:numToKey(x.n), t:Number(x.t)||now(), s:Number(x.s)||1})).filter(x=>x.n!==null);
      }
      sessionId = Number.isFinite(o.sessionId) ? Number(o.sessionId) : 1;
      windowN = [10,15,20].includes(o.windowN) ? o.windowN : 15;
    }catch(_){}
  }

  function windowValues(){ return spins.slice(0, windowN).map(x=>x.n); }

  function toCsv(){
    const c = (casino||"").replace(/"/g,'""');
    const lines = ["number,casino,date,time,session_id"];
    const arr = spins.slice().reverse();
    for(const x of arr){
      const d = new Date(x.t);
      const yyyy = String(d.getFullYear());
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      const n = (x.n==="00")?"00":String(x.n);
      lines.push(`${n},"${c}",${yyyy}-${mm}-${dd},${hh}:${mi}:${ss},${x.s}`);
    }
    return lines.join("\n");
  }

  async function copyText(t){
    try{
      await navigator.clipboard.writeText(t);
      return true;
    }catch(_){
      return false;
    }
  }

  function parseCommaList(s){
    const parts = String(s||"").split(",").map(x=>x.trim()).filter(Boolean);
    const out = [];
    for(const p of parts){
      const k = numToKey(p);
      if(k===null) return null;
      out.push(k);
    }
    return out;
  }

  // ---- Strategy definitions (HOW TO only in explain) ----
  const HOWTO = {
  "COMP — 6 Diamonds + 0/00": `How to play (COMP)
• Bet the 6 fixed corners (1 unit each corner) PLUS straight-up 0 and 00 (1 unit each).
• After a losing spin: +1 unit to ALL selected bets (cap progression as you prefer).
• After a winning spin: −1 unit to ALL selected bets (minimum 1 unit).
• Reset to base after a meaningful recovery / when near session high.`,

  "CASH — Junko Hot (Quadrant Momentum)": `How to play (CASH)
• Bet a small basket (typically 5–7 numbers) inside the hottest Junko quadrant.
• Flat bet is preferred; keep a short leash (10–15 spins) and re-check often.
• If the hottest quadrant changes, switch to the new hottest quadrant (or stop if unclear).`,

  "CASH — Gold Mine (Even-Money Compression)": `How to play (CASH)
• Bet ONE even‑money side (Red/Black OR High/Low OR Even/Odd) that is currently most concentrated.
• Flat bet only. Re-check every spin (or every few spins) using the last-15 window.
• Stop if the edge disappears or you hit your session stops.`,

  "COMP — Minimum Bet Placeholder": `How to play (COMP)
• Minimum bet / observe mode. Keep logging spins until the table becomes clearer.`,

  "CASH — Opposite-Segment Contrarian (Option 1)": `How to play (CASH)
• When a segment becomes hot in the last-15 window, bet the OPPOSITE segment until you hit once.
• Base unit = $1 per number.
• Escalate: +1 unit after 3 consecutive losing bet-spins.
• Session stops: cash-out +$100, stop-loss −$200 (guardrail: do not place any bet that could breach −$200 on a loss).`
};

  function scoreStrategies(vals){
    const plays = [];
    const add = (name, score) => plays.push({name, score});

    if(vals.length < 10){
      add("COMP — 6 Diamonds + 0/00", 70);
      return {plays: plays.sort((a,b)=>b.score-a.score).slice(0,3), primary: plays[0]};
    }

    // Junko heat
    const w15 = vals.slice(0,15);
    const c15 = counts(w15);
    const qMax = Math.max(c15.gn, c15.ho, c15.lo, c15.m);
    if(qMax >= 6) add("CASH — Junko Hot (Quadrant Momentum)", 92);
    else if(qMax >= 5) add("CASH — Junko Hot (Quadrant Momentum)", 80);

    // Opposite segment contrarian (activation threshold 6/15 in hottest segment with A→B→C→D tie-break)
    const segCounts = {A:0,B:0,C:0,D:0};
    for(const n of w15){
      const s = segOf(n);
      if(s) segCounts[s] += 1;
    }
    let hottest = "A";
    for(const s of TIE_ORDER){
      if(segCounts[s] > segCounts[hottest]) hottest = s;
    }
    if(segCounts[hottest] >= 6) add("CASH — Opposite Segment (Contrarian)", 88);

    // Repeat / choppy: comp coverage as fallback
    const rep = repeatInfo(vals, 5);
    if(rep.num || rep.street || rep.ds) add("COMP — 6 Diamonds + 0/00", 86);
    else add("COMP — 6 Diamonds + 0/00", 78);

    // A light even-money placeholder when nothing else is screaming
    add("CASH — Gold Mine (Even-Money Compression)", 72);

    plays.sort((a,b)=>b.score-a.score);
    const top = plays.slice(0,3);
    return {plays: top, primary: top[0]};
  }

  function buildTrendHTML(vals){
    const recent = vals.slice(0,15);
    const c = counts(recent);
    const ds = dsCounts(recent);

    const rep = repeatInfo(vals, 5);
    const repLine = `Repeats (last 5): number ${rep.num?"YES":"no"} • street ${rep.street?"YES":"no"} • DS ${rep.ds?"YES":"no"}`;

    return `
      <div class="hdr"><span class="b">Trend snapshot</span> <span class="pill">last 15</span></div>
      <div class="small muted">${repLine}</div>
      <div class="kv">
        <div class="card"><div class="k">Columns (C1/C2/C3)</div><div class="v mono">${c.c1} / ${c.c2} / ${c.c3}</div></div>
        <div class="card"><div class="k">Dozens (D1/D2/D3)</div><div class="v mono">${c.d1} / ${c.d2} / ${c.d3}</div></div>
        <div class="card"><div class="k">Double Streets (per dozen)</div><div class="v mono">D1 ${ds.d1[0]}/${ds.d1[1]}/${ds.d1[2]} | D2 ${ds.d2[0]}/${ds.d2[1]}/${ds.d2[2]} | D3 ${ds.d3[0]}/${ds.d3[1]}/${ds.d3[2]}</div></div>
        <div class="card"><div class="k">Red / Black</div><div class="v mono">${c.red} / ${c.black}</div></div>
        <div class="card"><div class="k">High / Low</div><div class="v mono">${c.high} / ${c.low}</div></div>
        <div class="card"><div class="k">Even / Odd</div><div class="v mono">${c.even} / ${c.odd}</div></div>
        <div class="card" style="grid-column:1/-1"><div class="k">Junko quadrants</div><div class="v mono">GN ${c.gn} | HO ${c.ho} | LO ${c.lo} | M ${c.m}</div></div>
      </div>
    `;
  }

  function wheelHistogramText(lastN=20){
    const WHEEL = [0,28,9,26,30,11,7,20,32,17,5,22,34,15,3,24,36,13,1,"00",27,10,25,29,12,8,19,31,18,6,21,33,16,4,23,35,14,2];
    const slice = spins.slice(0,lastN).map(x=>x.n);
    const cts = {};
    for(const n of slice){
      const k = (n==="00")?"00":String(n);
      cts[k] = (cts[k]||0)+1;
    }
    const maxC = Math.max(1, ...WHEEL.map(n=>cts[(n==="00")?"00":String(n)]||0));
    const bar = (k)=>"█".repeat(Math.round((k/maxC)*8));
    let out = `<div class="hdr"><span class="b">Wheel</span> <span class="pill">last ${lastN}</span></div>`;
    out += `<div class="small muted">Hit histogram by pocket (American wheel order)</div>`;
    out += `<div class="small mono" style="white-space:pre-wrap;line-height:1.35;margin-top:8px">`;
    for(const n of WHEEL){
      const key=(n==="00")?"00":String(n);
      const c=cts[key]||0;
      if(c>0){
        out += `${key.padStart(2," ")}: ${String(c).padStart(2," ")}  ${bar(c)}\n`;
      }
    }
    out += `</div>`;
    return out;
  }

  function statusHTML(vals){
    const scored = scoreStrategies(vals);
    const top = scored.plays.map((p,i)=>`${i+1}. ${p.name}  <span class="pill">${p.score}</span>`).join("<br/>");
    return `
      <div class="hdr"><span class="b">Status</span> <span class="pill">${casino?casino:"no casino"}</span></div>
      <div class="small muted">Window: last ${windowN} • Spins logged: ${spins.length} • Session: ${sessionId}</div>
      <div class="small" style="margin-top:8px"><span class="b">Top 3</span><br/>${top}</div>
      <div class="small muted" style="margin-top:8px">Tip: text <span class="mono">trend</span> for the stat grid. Text <span class="mono">explain</span> (or <span class="mono">explain 2</span>) for how to play.</div>
    `;
  }

  function helpText(){
    return `Help (commands)
- status : top 3 strategies (name + score)
- trend  : stat grid (columns/dozens/DS/RB/HL/EO/Junko + repeat flags)
- wheel  : wheel histogram (last 20)
- explain : how to play the #1 strategy shown in status
- explain 2 : how to play the #2 strategy
- export : copy CSV (works offline)
- offline : offline reminders + backup tips
- clear  : wipe spins + reset session

Input
- Send a single spin: 17 or 00
- Send a short list: 10,12,4
- Paste full history once: 0,00,34,23,45,... (comma-separated)

Casino prompt
- After your first pasted history, the app asks which casino you're at.
  Reply with the name (e.g., "Caesars" or "Harrah's Joliet").`;
  }

  function offlineText(){
    return `Offline reminders (cruise / airplane mode)
- This runs fully offline after the page loads once.
- Spins and casino name are saved on-device (localStorage).
- Export: text "export" to copy CSV to clipboard (no internet needed).
- Backup tip: after exporting, paste the CSV into Notes or email draft so you have a second copy.
- Import later: you can paste exported CSV into a desktop tool, or re-enter history as a comma list.`;
  }

  function clearAll(){
    spins = [];
    sessionId = 1;
    awaitingCasino = false;
    casino = "";
    save();
    pushBubble("Cleared. Paste history or send spins to start.", false);
  }

  function addSpin(n){
    spins.unshift({n, t: now(), s: sessionId});
    if(spins.length > 5000) spins = spins.slice(0,5000);
    save();
  }

  function ingestList(list, isFirstHistory){
    // treat list as chronological if it looks like a paste (more than 6 numbers)
    const isChrono = list.length >= 7;
    const arr = isChrono ? list.slice() : list.slice(); // already given order; we will add sequential with increasing time
    // Append to history chronologically: oldest first
    const baseT = now() - arr.length*250;
    for(let i=0;i<arr.length;i++){
      const n = arr[i];
      spins.unshift({n, t: baseT + i*250, s: sessionId}); // unshift but time increasing so sorting later
    }
    // Normalize: sort newest-first by time
    spins.sort((a,b)=>b.t-a.t);
    if(spins.length > 5000) spins = spins.slice(0,5000);
    save();

    if(isFirstHistory){
      awaitingCasino = true;
      save();
      pushBubble("Got it. Which casino are you at? (reply with a short name)", false);
    } else {
      pushBubble(statusHTML(windowValues()), false, true);
    }
  }

  function formatNums(arr){
  return arr.map(x => (x==="00" ? "00" : String(x))).join(", ");
}

function fixed6DiamondsNums(){
  return {
    corners: [
      [1,2,3,5],
      [7,8,9,11],
      [13,14,15,17],
      [19,20,21,23],
      [25,26,27,29],
      [31,32,33,35],
    ],
    greens: [0,"00"]
  };
}

function hottestJunkoBucket(vals){
  const w = vals.slice(0,15);
  const c = {GN:0, HO:0, LO:0, M:0};
  for(const n of w){
    const b = junkoBucket(n);
    if(b) c[b] += 1;
  }
  const order = ["GN","HO","LO","M"];
  let best = order[0];
  for(const k of order){ if(c[k] > c[best]) best = k; }
  return {bucket: best, counts: c};
}

function junkoBucketNumbers(bucket){
  const map = {
    GN: ["00",0,1,2,9,10,13,14,27,28],
    HO: [24,25,26,29,30,33,34,35,36],
    LO: [3,4,8,11,12,15,16,22,23],
    M:  [5,6,7,17,18,19,20,21,31,32],
  };
  return map[bucket] || [];
}

function topNumbersInSet(vals, setArr, topK=5){
  const freq = new Map();
  const allowed = new Set(setArr.map(x => (x==="00" ? "00" : String(x))));
  for(const n of vals.slice(0,15)){
    const k = (n==="00") ? "00" : String(n);
    if(allowed.has(k)) freq.set(k, (freq.get(k)||0)+1);
  }
  const sorted = [...freq.entries()].sort((a,b)=>b[1]-a[1]);
  const pick = [];
  for(const [k] of sorted){
    pick.push(k==="00" ? "00" : Number(k));
    if(pick.length>=topK) break;
  }
  if(pick.length < topK){
    for(const x of setArr){
      if(pick.some(p=>String(p)===String(x))) continue;
      pick.push(x);
      if(pick.length>=topK) break;
    }
  }
  return pick;
}

function goldMineSide(vals){
  const w = vals.slice(0,15);
  let red=0, black=0, high=0, low=0, even=0, odd=0;
  for(const n of w){
    if(isGreen(n)) continue;
    if(isRed(n)) red++; if(isBlack(n)) black++;
    if(isHigh(n)) high++; if(isLow(n)) low++;
    if(isEven(n)) even++; if(isOdd(n)) odd++;
  }
  const options = [
    {label:"Red", a:red, b:black},
    {label:"Black", a:black, b:red},
    {label:"High (19–36)", a:high, b:low},
    {label:"Low (1–18)", a:low, b:high},
    {label:"Even", a:even, b:odd},
    {label:"Odd", a:odd, b:even},
  ];
  options.sort((x,y)=> (y.a - y.b) - (x.a - x.b));
  return {side: options[0].label, margin: options[0].a - options[0].b};
}

function oppositeSegmentTargets(vals){
  const w = vals.slice(0,15);
  const c = {A:0,B:0,C:0,D:0};
  for(const n of w){
    const seg = segmentOf(n);
    if(seg) c[seg] += 1;
  }
  const order = ["A","B","C","D"];
  let hottest = order[0];
  for(const k of order){ if(c[k] > c[hottest]) hottest = k; }
  const betSeg = oppositeOf(hottest);
  return {hottest, betSeg, counts:c, nums: segSet[betSeg]};
}

function explainHTML(name, vals){
  const key = (name||"").trim();

  if(key === "COMP — 6 Diamonds + 0/00"){
    const d = fixed6DiamondsNums();
    const cornerLines = d.corners.map(g => `• Corner: ${formatNums(g)}`).join("<br>");
    return `<b>${key}</b><br><span class="muted">Numbers to bet</span><br>${cornerLines}<br>• 0 and 00 (straight)<br><div style="height:1px;background:rgba(255,255,255,.10);margin:10px 0"></div><span class="muted">How to play</span><br>${HOWTO[key].replace(/\n/g,"<br>")}`;
  }

  if(key === "CASH — Junko Hot (Quadrant Momentum)"){
    const hot = hottestJunkoBucket(vals);
    const nums = junkoBucketNumbers(hot.bucket);
    const suggested = topNumbersInSet(vals, nums, 5);
    return `<b>${key}</b><br><span class="muted">Numbers to bet</span><br>• Hottest quadrant now: <b>${hot.bucket}</b><br>• Quadrant set: ${formatNums(nums)}<br>• Suggested 5 now: <b>${formatNums(suggested)}</b><br><div style="height:1px;background:rgba(255,255,255,.10);margin:10px 0"></div><span class="muted">How to play</span><br>${HOWTO[key].replace(/\n/g,"<br>")}`;
  }

  if(key === "CASH — Gold Mine (Even-Money Compression)"){
    const best = goldMineSide(vals);
    return `<b>${key}</b><br><span class="muted">Bet to place</span><br>• <b>${best.side}</b> (even-money)<br><div style="height:1px;background:rgba(255,255,255,.10);margin:10px 0"></div><span class="muted">How to play</span><br>${HOWTO[key].replace(/\n/g,"<br>")}`;
  }

  if(key === "CASH — Opposite-Segment Contrarian (Option 1)"){
    const o = oppositeSegmentTargets(vals);
    const nums = o.nums.map(x => (x===99 ? "00" : x));
    return `<b>${key}</b><br><span class="muted">Numbers to bet</span><br>• Opposite of hottest segment (<b>${o.hottest}</b> → <b>${o.betSeg}</b>)<br>• Bet segment numbers: <b>${formatNums(nums)}</b><br><div style="height:1px;background:rgba(255,255,255,.10);margin:10px 0"></div><span class="muted">How to play</span><br>${HOWTO[key].replace(/\n/g,"<br>")}`;
  }

  const how = HOWTO[key] || HOWTO["COMP — Minimum Bet Placeholder"] || "—";
  return `<b>${key}</b><br><span class="muted">How to play</span><br>${String(how).replace(/\n/g,"<br>")}`;
}

function explainRank(rank){
  const vals = windowValues();
  const scored = scoreStrategies(vals);
  const picks = scored.top;
  const idx = Math.max(0, Math.min(picks.length-1, (rank||1)-1));
  const p = picks[idx];
  if(!p){
    pushBubble("No strategy available yet. Add some spins first.", false);
    return;
  }
  pushBubble(explainHTML(p.name, vals), false, true);
}
    const t = HOWTO[p.name] || ("No how-to available for: " + p.name);
    pushBubble(t, false);
  }

  function handleCommand(cmdRaw){
    const cmd = String(cmdRaw||"").trim().toLowerCase();

    if(cmd === "help"){
      pushBubble(helpText(), false);
      return true;
    }
    if(cmd === "offline"){
      pushBubble(offlineText(), false);
      return true;
    }
    if(cmd === "clear"){
      clearAll();
      return true;
    }
    if(cmd === "status"){
      pushBubble(statusHTML(windowValues()), false, true);
      return true;
    }
    if(cmd === "trend"){
      pushBubble(buildTrendHTML(windowValues()), false, true);
      return true;
    }
    if(cmd === "wheel"){
      pushBubble(wheelHistogramText(20), false, true);
      return true;
    }
    if(cmd === "export"){
      const csv = toCsv();
      copyText(csv).then(ok=>{
        if(ok) pushBubble("Export copied (CSV). Paste into Notes/Email for backup.", false);
        else pushBubble("Clipboard blocked. Copy this CSV manually:\n\n" + csv, false);
      });
      return true;
    }
    if(cmd === "explain"){
      explainRank(1);
      return true;
    }
    if(cmd === "explain 2" || cmd === "explain2"){
      explainRank(2);
      return true;
    }
    return false;
  }

  function onSend(){
    const raw = ($("msg").value||"").trim();
    if(!raw) return;

    pushBubble(raw, true);
    $("msg").value = "";

    // If we're awaiting casino name, treat anything that isn't a command as casino
    if(awaitingCasino){
      if(handleCommand(raw)) return;
      casino = raw;
      awaitingCasino = false;
      save();
      pushBubble("Saved casino: " + casino + ". Text status or trend when ready.", false);
      return;
    }

    // Commands
    if(handleCommand(raw)) return;

    // Single number?
    const single = numToKey(raw);
    if(single !== null && String(raw).indexOf(",") === -1){
      addSpin(single);
      pushBubble(statusHTML(windowValues()), false, true);
      return;
    }

    // Comma list?
    if(raw.includes(",")){
      const list = parseCommaList(raw);
      if(!list){
        pushBubble("Unrecognized. Send numbers like 17, 00, or a comma list like 0,00,34,23.", false);
        return;
      }
      const isFirstHistory = spins.length === 0;
      ingestList(list, isFirstHistory);
      return;
    }

    pushBubble("Unrecognized. Text help for commands, or send a spin like 17 / 00.", false);
  }
  window.__stealthOnSend = onSend;


  function seedIntro(){
    if(spins.length === 0){
      pushBubble("Paste history (comma-separated). After that, text single spins or commands.", false);
    } else {
      pushBubble(statusHTML(windowValues()), false, true);
      if(awaitingCasino){
        pushBubble("Which casino are you at? (reply with a short name)", false);
      }
    }
  }

  // init
  load();
  $("buildLine").textContent = "Texting view • STEALTH TEXT MODE — " + VERSION + " (Opposite Segment strategy added)";
  $("send").addEventListener("click", onSend);
  $("msg").addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); onSend(); } });

  seedIntro();
})();
</script>

<script>
/* STEALTH v1.0 send binding hardening
   Fix: ensure Send works across differing element IDs and if earlier scripts failed to bind.
*/
(function(){
  function byIdList(ids){ for(const id of ids){ const el=document.getElementById(id); if(el) return el; } return null; }
  function bind(){
    const input = byIdList(["msgInput","messageInput","textInput","input","chatInput"]);
    const send  = byIdList(["sendBtn","send","sendButton","btnSend"]);
    const form  = document.querySelector("form");
    const fn = (typeof window.__stealthOnSend === "function") ? window.__stealthOnSend
             : (typeof window.onSend === "function") ? window.onSend
             : (typeof window.handleSend === "function") ? window.handleSend
             : (typeof window.sendMessage === "function") ? window.sendMessage
             : null;

    function doSend(){
      if(typeof fn === "function"){
        fn();
        return;
      }
      if(send){
        send.dispatchEvent(new MouseEvent("click",{bubbles:true,cancelable:true}));
      }
    }

    if(send){
      send.addEventListener("click", function(e){ e.preventDefault(); e.stopPropagation(); doSend(); }, true);
      send.style.pointerEvents = "auto";
    }

    if(form){
      form.addEventListener("submit", function(e){ e.preventDefault(); doSend(); }, true);
    }

    if(input){
      input.addEventListener("keydown", function(e){
        if(e.key === "Enter"){
          e.preventDefault();
          doSend();
        }
      }, true);
    }
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bind);
  } else {
    bind();
  }
})();
</script>

</body>
</html>
