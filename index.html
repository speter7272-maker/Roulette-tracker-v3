<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roulette Trend Tracker • FULL • CASH PRIORITY v15.3.2 LOCKED.1.17</title>
  <style>
    :root{color-scheme:dark; --bg:#0b1220; --card:#0f1a2e; --muted:#94a3b8; --txt:#e5e7eb; --accent:#60a5fa; --warn:#fbbf24; --danger:#ef4444; --ok:#34d399; --chip:#111c33; --border:#1f2a44;}
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#070b14,#0b1220 40%,#070b14);color:var(--txt)}
    .wrap{max-width:980px;margin:0 auto;padding:18px 14px 40px}
    h1{font-size:28px;margin:0 0 6px;letter-spacing:.2px}
    .build{margin-top:6px;color:#c7d2fe;font-weight:800;font-size:14px}
    .sub{color:var(--muted);font-size:12px;margin:8px 0 12px;line-height:1.35}
    .card{background:rgba(15,26,46,.88);border:1px solid var(--border);border-radius:16px;padding:14px;margin:12px 0;box-shadow:0 8px 28px rgba(0,0,0,.25)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:8px 10px;font-size:12px;color:var(--muted)}
    .pill b{color:var(--txt)}
    .btn{appearance:none;border:1px solid var(--border);background:var(--chip);color:var(--txt);padding:10px 12px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.small{padding:6px 10px;font-size:12px;border-radius:10px}
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:rgba(96,165,250,.45);background:rgba(96,165,250,.18)}
    .btn.danger{border-color:rgba(239,68,68,.45);background:rgba(239,68,68,.12)}
    input[type="text"], textarea{width:100%;border-radius:14px;border:1px solid var(--border);background:#0b152b;color:var(--txt);padding:10px}
    textarea{min-height:92px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:860px){.grid{grid-template-columns:1.1fr .9fr}}
    .kbd{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;position:relative;z-index:5;}
    /* KEYPAD_SAFETY */
    #kbd, #kbd *{pointer-events:auto;}
    #kbd{touch-action:manipulation;}

    .key{padding:12px 8px;border-radius:12px;border:1px solid var(--border);background:#0c1730;color:var(--txt);font-weight:900;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;touch-action:manipulation;
    }
    .key.green{background:rgba(16,185,129,.16);border-color:rgba(16,185,129,.35)}
    .key.zero{background:rgba(245,158,11,.16);border-color:rgba(245,158,11,.35)}
    .key:active{transform:translateY(1px)}
    .stat{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .box{background:#0c1730;border:1px solid var(--border);border-radius:14px;padding:10px}
    .k{color:var(--muted);font-size:11px}
    .v{font-size:16px;font-weight:900;margin-top:2px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hr{height:1px;background:var(--border);margin:12px 0}
    .topplays{display:grid;grid-template-columns:1fr;gap:8px}
    .playcard{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);padding:10px;border-radius:12px}
    .playhdr{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .tag{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);opacity:.9}
    .small{font-size:12px;opacity:.9;line-height:1.25}
    /* modal */
    #expModal{display:none;position:fixed;inset:0;z-index:9999;}
    #expBackdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
    #expCard{position:relative;max-width:720px;margin:8vh auto;background:#111827;color:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.45);padding:16px 16px 12px 16px}
    #expBody{margin:12px 0 0 0;white-space:pre-wrap;word-wrap:break-word;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;font-size:12px;line-height:1.35;background:rgba(255,255,255,.06);padding:12px;border-radius:12px;max-height:58vh;overflow:auto}
    /* Wheel modal */
    .modalOverlay{
      position:fixed; inset:0; z-index:9999;
      background:rgba(0,0,0,0.55);
      display:flex; align-items:center; justify-content:center;
      padding:14px;
      backdrop-filter: blur(6px);
    }
    .modalCard{
      width:min(680px, 100%);
      background:rgba(20,28,45,0.95);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      padding:14px;
    }
    .modalHeader{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Roulette Trend Tracker</h1>
    <div id="buildStamp" class="pill" style="display:inline-block;margin-top:6px">Build: 2026-01-13 • FULL • CASH PRIORITY v15.3.2 LOCKED.1.17</div>
    <div class="build">FULL TRACKER — CASH PRIORITY + NEW STRATEGIES • v15.3.2 LOCKED.1.17</div>
    <div class="sub">Build date: <b>2026-01-09</b>. Tap spins on the keypad. Tracks last 10/15/20: columns, dozens, double-streets, red/black, high/low, even/odd, Junko quadrants. Saves on-device.</div>

    <div class="card">
      <div class="row">
        <div class="pill">Window: <b id="winLabel">Last 15</b></div>
        <div class="pill">Spins: <b id="spinCount">0</b></div>
        <div class="pill">Session: <b id="sessionCount">0</b></div>
        <div class="pill">Green: <b id="greenCount">0</b></div>
          <div class="pill">GDC: <b id="greenDrought">0</b></div>
      </div>
      <div class="row" style="margin-top:10px">
        <label class="pill" style="gap:10px; align-items:center; width:100%">
          Casino:
          <input id="casinoInput" type="text" placeholder="e.g., Caesars / Harrah’s Joliet" style="flex:1; min-width:180px" />
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="undoBtn" type="button">Undo</button>
        <button class="btn danger" id="clearBtn" type="button">Clear</button>
        <button class="btn" id="use15Btn" type="button">Use last 15</button>
        <button class="btn" id="use10Btn" type="button">Use last 10</button>
        <button class="btn" id="use20Btn" type="button">Use last 20</button>
        <button class="btn" id="newSessionBtn" type="button">New Session</button>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div style="font-weight:900;margin-bottom:8px">Quick input</div>
        <div class="row">
          <input id="manualInput" type="text" placeholder="Type: 0–36 or 00" inputmode="text" />
          <button class="btn primary" id="addManualBtn" type="button">Add</button>
        </div>
        <div class="small" style="margin-top:8px">Tip: On iPhone, the keypad is usually fastest. Manual input is a backup.</div>

        <div class="hr"></div>

        <div id="keypadAnchor" style="font-weight:900;margin-bottom:8px">Tap keypad</div>
        <div id="kpDebug" class="small mono" style="margin:6px 0 10px; opacity:.9">Keypad taps: 0</div>
        <div class="kbd" id="kbd"></div>
      </div>

      <div class="hr"></div>

      <div style="font-weight:900;margin-bottom:8px">Last 20 (newest first)</div>
        <textarea id="lastList" readonly placeholder="No spins yet."></textarea>

        <div class="hr"></div>

        <div class="row" style="gap:10px;flex-wrap:wrap">
          <button class="btn" id="copyCsvBtn" type="button">Copy CSV</button>
          <button class="btn" id="downloadCsvBtn" type="button">Download CSV</button>
          <button class="btn" id="wheelViewBtn" type="button">Wheel View (Last 20)</button>
        </div>

      <div class="card">
        <div style="font-weight:900;margin-bottom:8px">Trend + tracking</div>

        <div class="stat">
          <div class="box">
            <div class="k">Recommended play</div>
            <div class="v" id="recommend">Sit out</div>
            <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
              <button id="primaryExplainBtn" class="btn small" type="button" style="display:none">Explain</button>
            </div>
            <div class="k" id="reason" style="margin-top:8px">No data yet.</div>
          </div>
        <div id="trendAlert" class="alert" style="display:none;margin-top:10px">
          <div style="font-weight:800;margin-bottom:4px">Trend change alert</div>
          <div id="trendAlertText">—</div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" id="trendDismissBtn" type="button">Dismiss</button>
          </div>
        </div>
        
          <div class="box">
            <div class="k">Table state</div>
            <div class="v" id="state">—</div>
            <div class="k" id="state2">—</div>
          </div>
        </div>
          <div class="box">
            <div class="k">Repeat numbers (≤5 spins)</div>
            <div class="v mono" id="repNums">—</div>
            <div class="k" id="repNums2">—</div>
          </div>
          <div class="box">
            <div class="k">Repeat streets (≤3 spins)</div>
            <div class="v mono" id="repStreets">—</div>
            <div class="k" id="repStreets2">—</div>
          </div>
          <div class="box">
            <div class="k">Hydra coldest 4 (since green)</div>
            <div class="v mono" id="hydraCold4">—</div>
            <div class="k" id="hydraCold4b">—</div>
          </div>
          <div class="box">
            <div class="k">Dirty Bird DB‑CDS (last15 no‑green)</div>
            <div class="v mono" id="dbcds">—</div>
            <div class="k" id="dbcds2">—</div>
          </div>

          <div class="box">
            <div class="k">12 Soldiers (last15 selection)</div>
            <div class="v mono" id="soldiers">—</div>
            <div class="k" id="soldiers2">—</div>
          </div>

          <div class="box">
            <div class="k">Green Add-on (GSAH-15)</div>
            <div class="v mono" id="gsah">—</div>
            <div class="k" id="gsah2">—</div>
          </div>


        <div class="hr"></div>

        <div style="font-weight:900;margin-bottom:8px">
<div class="card">
  <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
    <div style="font-weight:900">Wheel Wave (band 3)</div>
    <div class="pill">10/15</div>
  </div>
  <div class="sub" style="margin-top:6px">Measures whether adjacent spins cluster within ±3 (SAME) or disperse (OPP).</div>
  <div class="grid2" style="margin-top:10px">
    <div class="mini">
      <div class="k">Last 10</div>
      <div class="v mono" id="wave10">—</div>
    </div>
    <div class="mini">
      <div class="k">Last 15</div>
      <div class="v mono" id="wave15">—</div>
    </div>
  </div>
</div>

Top 3 strategies right now</div>
        <div id="topPlays" class="topplays"></div>

        <div class="hr"></div>

        <div class="stat">
          <div class="box"><div class="k">Columns (C1/C2/C3)</div><div class="v mono" id="cols">0 / 0 / 0</div></div>
          <div class="box"><div class="k">Dozens (D1/D2/D3)</div><div class="v mono" id="doz">0 / 0 / 0</div></div>
          <div class="box"><div class="k">Double Streets (per dozen)</div><div class="v mono" id="ds">D1 — | D2 — | D3 —</div></div>
          <div class="box"><div class="k">Red / Black</div><div class="v mono" id="rb">0 / 0</div></div>
          <div class="box"><div class="k">High / Low</div><div class="v mono" id="hl">0 / 0</div></div>
          <div class="box"><div class="k">Even / Odd</div><div class="v mono" id="eo">0 / 0</div></div>
          <div class="box"><div class="k">Junko quadrants</div><div class="v mono" id="junko">GN 0 | HO 0 | LO 0 | M 0</div></div>
        </div>

        <div class="hr"></div>

        

        <div class="card" style="margin-top:14px;">
          <div style="font-weight:900">Import session CSV (append to history)</div>
          <div class="small" style="margin-top:6px">Paste CSV with header: <span class="mono">number,casino,date,time,session_id</span>, then tap Import.</div>
          <textarea id="importArea" style="height:120px; margin-top:10px;" placeholder="Paste CSV here..."></textarea>
          <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
            <button class="btn primary" id="importBtn" type="button">Import CSV</button>
            <button class="btn" id="clearImportBtn" type="button">Clear Import Box</button>
          </div>
          <div class="small" id="importStatus" style="margin-top:8px;"></div>
        </div>

      </div>
    </div>
  </div>

  <!-- Explain modal -->
  <div id="expModal">
    <div id="expBackdrop"></div>
    <div id="expCard">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
        <div id="expTitle" style="font-weight:900;font-size:16px;line-height:1.2">Strategy details</div>
        <button id="expClose" class="btn small" type="button" style="background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.18);">Close</button>
      </div>
      <pre id="expBody"></pre>
    </div>
  </div>

  <!-- Wheel View Modal -->
  <div id="wheelModal" class="modalOverlay" style="display:none;">
    <div class="modalCard">
      <div class="modalHeader">
        <div>
          <div class="h2" style="margin:0;">American Wheel — Last 20</div>
          <div class="hint" id="wheelSubtitle" style="margin-top:4px;">Radial bars show hit count per pocket (most recent 20 spins).</div>
        </div>
        <button class="btn" id="wheelCloseBtn" type="button">Close</button>
      </div>
      <canvas id="wheelCanvas" width="420" height="420" style="width:100%; max-width:520px; border-radius:16px; background:rgba(255,255,255,0.03);"></canvas>
      <div class="hint" style="margin-top:10px;">
        Tip: Longer / more stacked bars = more hits in the last 20. Green pockets are 0 and 00.
      </div>
    </div>
  </div>
<script>

  console.log("Roulette Tracker BUILD v15.3.2 LOCKED (scoreTrinity fix)");

  // DOM helpers
  const $ = (id) => document.getElementById(id);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function on(id, evt, fn, opts){
    const el = $(id);
    if (!el) return;
    el.addEventListener(evt, fn, opts);
  }

document.addEventListener('DOMContentLoaded', () => {
  const STORAGE_KEY = "roulette_trend_tracker_base_keypad_tracking_v1";
  const ACTIVE_KEY = "roulette_active_strategy_v1";
  const RED = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
  const BLACK = new Set([2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35]);

  // Junko quadrants mapping (as previously used)
  const GN = new Set(["00",0,1,2,9,10,13,14,27,28]);
  const HO = new Set([24,25,26,29,30,33,34,35,36]);
  const LO = new Set([3,4,8,11,12,15,16,22,23]);
  const MID= new Set([5,6,7,17,18,19,20,21,31,32]);

  let spins = []; // newest-first: {n,t,s}
  // Green drought counter (GDC): increments on non-green spins, resets on 0/00
  let gdc = 0;

  // Green Split Add-On Hedge (GSAH-15): state machine for optional overlay betting
  let gsah = {
    state: "OFF",        // OFF | ARMED | ACTIVE
    armed: false,
    u: 1,
    lossCount: 0,        // hedge losses since last u bump
    betSpins: 0,         // hedge bet-spins since activation
    pnlU: 0,             // hedge PnL in units (for -12u budget)
    pending: false,      // whether hedge bet was placed for the next spin resolution
    pendingU: 1,
    offReason: ""
  };

  let windowN = 15;
  let sessionId = 1;

  const trendDismissBtn = $("trendDismissBtn");
  const trendAlert = $("trendAlert");

  function numToKey(n) {
    if (n === "00") return "00";
    if (typeof n === "string" && n.trim() === "00") return "00";
    const v = Number(n);
    return Number.isFinite(v) ? v : null;
  }

  function isGreen(n) { return (n === "00" || Number(n) === 0); }
  function isRed(n)   { return (n !== "00" && RED.has(Number(n))); }
  function isBlack(n) { return (n !== "00" && BLACK.has(Number(n))); }
  function isHigh(n)  { return (n !== "00" && Number(n) >= 19); }
  function isLow(n)   { return (n !== "00" && Number(n) >= 1 && Number(n) <= 18); }
  function isEven(n)  { return (n !== "00" && Number(n) !== 0 && Number(n)%2===0); }
  function isOdd(n)   { return (n !== "00" && Number(n)%2===1); }

  function colOf(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    const r = v % 3;
    return r === 1 ? 1 : (r === 2 ? 2 : 3);
  }
  function dozenOf(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    return v<=12 ? 1 : (v<=24 ? 2 : 3);
  }
  function streetId(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    return Math.floor((v-1)/3) + 1; // 1..12
  }
  function junkoBucket(n) {
    const k = (n==="00") ? "00" : Number(n);
    if (GN.has(k)) return "GN";
    if (HO.has(k)) return "HO";
    if (LO.has(k)) return "LO";
    if (MID.has(k)) return "M";
    return null;
  }

  function dsKey(n) {
    if (n === "00" || n === 0) return null;
    const v = Number(n);
    if (!(v>=1 && v<=36)) return null;
    const d = v<=12 ? 1 : (v<=24 ? 2 : 3);
    const base = (d-1)*12;
    const a = base+1, b = base+4, c = base+7;
    if (v>=a && v<=a+5) return {d:d, i:1};
    if (v>=b && v<=b+5) return {d:d, i:2};
    if (v>=c && v<=c+5) return {d:d, i:3};
    return {d:d, i:2};
  }
  function dsCounts(vals) {
    const out = {d1:[0,0,0], d2:[0,0,0], d3:[0,0,0]};
    vals.forEach((n)=>{
      const k = dsKey(n);
      if(!k) return;
      const arr = (k.d===1?out.d1:(k.d===2?out.d2:out.d3));
      arr[k.i-1] += 1;
    });
    return out;
  }

  function counts(vals) {
    const c = {c1:0,c2:0,c3:0,d1:0,d2:0,d3:0,red:0,black:0,high:0,low:0,even:0,odd:0,gn:0,ho:0,lo:0,m:0,green:0};
    vals.forEach((n)=>{
      if(isGreen(n)) c.green++;
      const col = colOf(n); if(col===1)c.c1++; if(col===2)c.c2++; if(col===3)c.c3++;
      const d = dozenOf(n); if(d===1)c.d1++; if(d===2)c.d2++; if(d===3)c.d3++;
      if(isRed(n)) c.red++;
      if(isBlack(n)) c.black++;
      if(isHigh(n)) c.high++;
      if(isLow(n)) c.low++;
      if(isEven(n)) c.even++;
      if(isOdd(n)) c.odd++;
      const jb = junkoBucket(n);
      if(jb==="GN") c.gn++;
      if(jb==="HO") c.ho++;
      if(jb==="LO") c.lo++;
      if(jb==="M") c.m++;
    });
    return c;
  }

  // Spins since last Junko quadrant hit (0 = hit on most recent spin)
  // If a quadrant never appears in the current window, value stays 999.
  function junkoAges(vals){
    // vals expected newest-first
    const out = {gn:999, ho:999, lo:999, m:999};
    for (let i = 0; i < vals.length; i++) {
      const jb = junkoBucket(vals[i]);
      if (jb === "GN" && out.gn === 999) out.gn = i;
      else if (jb === "HO" && out.ho === 999) out.ho = i;
      else if (jb === "LO" && out.lo === 999) out.lo = i;
      else if (jb === "M"  && out.m  === 999) out.m  = i;
      if (out.gn !== 999 && out.ho !== 999 && out.lo !== 999 && out.m !== 999) break;
    }
    return out;
  }

  // Spins-since-last-hit (within the current window), per column / dozen
  function colAges(vals){
    const out={c1:999,c2:999,c3:999};
    for(let i=0;i<vals.length;i++){
      const n=vals[i];
      if(n==null||isGreen(n)) continue;
      const c=colOf(n);
      if(c===1 && out.c1===999) out.c1=i;
      if(c===2 && out.c2===999) out.c2=i;
      if(c===3 && out.c3===999) out.c3=i;
    }
    return out;
  }

  function dozenAges(vals){
    const out={d1:999,d2:999,d3:999};
    for(let i=0;i<vals.length;i++){
      const n=vals[i];
      if(n==null||isGreen(n)) continue;
      const d=dozenOf(n);
      if(d===1 && out.d1===999) out.d1=i;
      if(d===2 && out.d2===999) out.d2=i;
      if(d===3 && out.d3===999) out.d3=i;
    }
    return out;
  }


  function repeatNumberInfo(vals, lookback) {
    if(vals.length<2) return {flag:false, text:"—"};
    const newest = vals[0];
    const slice = vals.slice(1, Math.min(vals.length, lookback));
    for(let i=0;i<slice.length;i++) {
      if(slice[i]===newest) return {flag:true, text:String(newest)+" repeated within "+(i+1)+" spins"};
    }
    return {flag:false, text:"—"};
  }
  function repeatStreetInfo(vals, lookback) {
    if(vals.length<2) return {flag:false, text:"—"};
    const s0 = streetId(vals[0]);
    if(!s0) return {flag:false, text:"—"};
    for(let i=1;i<Math.min(vals.length, lookback); i++) {
      const si = streetId(vals[i]);
      if(si && si===s0) return {flag:true, text:"Street "+s0+" repeated within "+i+" spins"};
    }
    return {flag:false, text:"—"};
  }

  const STRATEGY_DETAILS = {
    "6 Diamonds + 0/00 (Primary)":
`6 Diamonds + 0/00 (Primary)

Default forced-play strategy (COMP)
- Wide coverage grinder for survivability.
- Progression capped at Step 1 in COMP mode.

Core
- Use your 6 Diamonds corner structure.
- Add 0/00 split as your table allows (American wheel).

Exit / Mode rules
- Stay in COMP when CASH score < 85 or during cooldowns.
- Switch to CASH only after a reset/completed progression/milestone (per session rules).`,

    "Point Pusher":
`Point Pusher (COMP)

Profile
- Column + corners + basket.
- Smooth ADT profile.
- Flat betting.

Use when
- COMP mode default/fallback.
- Table is flat/choppy without a strong bias.`,

    "Junko Dry (Flat)":
`Junko Dry (COMP)

Use when
- Quadrant droughts / weak Junko signal.
- Low volatility, slow bleed.

Rule
- Flat only.
- Recompute every spin using your chosen window.`,

    "DS Cash Power (Base Only)":
`DS Cash Power (COMP Base)

Use when
- Mild clustering is present but you do NOT want ladder risk.

Rule
- Base engagement only (no escalation).
- Reset/exit on any hostile shift.`,

    "Minimum Bet Placeholder":
`Minimum Bet Placeholder (COMP)

Use when
- Extreme noise / greens heavy.
- Near stop-loss conditions.

Rule
- Minimum engagement to stay betting.
- Focus on survivability until structure improves.`,

    "Slow & Steady (Structural Bias)":
`Slow & Steady (CASH)

Score driver
- Dozen / Column concentration.

Use when
- D or C dominance is extreme and CASH qualifies (rank #1, score ≥ 85).

Constraints
- Bet cap: 4u per bet.
- Immediate exit on structure break.`,

    "DS Cash Power (Street Cluster)":
`DS Cash Power (CASH)

Score driver
- Double street clustering + repeats.

Use when
- One DS bucket is clearly dominant and CASH qualifies.

Abort
- If DS score weakens at reassessment.`,

    "Gold Mine (Even-Money Compression)":
`Gold Mine (CASH)

Score driver
- High / Low dominance.

Rules
- Option A (no hedge).
- Exit as soon as dominance drops.`,

    "Follow-the-Leader 50/50":
`Follow-the-Leader 50/50 (CASH)

Score driver
- Run length + dominance.

Use when
- Run ≥ 3 AND dominance ≥ 12/20 and CASH qualifies.

Exit
- First streak break.`,

    "Junko Hot (Quadrant Momentum)":
`Junko Hot (CASH)

Score driver
- Quadrant momentum (e.g., ≥ strong threshold).

Rules
- Flat only.
- Short leash (10–15 spins).
- Exit immediately if score degrades.`,

    "Win 28 (Coverage Probe)":
`Win 28 (CASH)

Score driver
- Coverage / dispersion (last-20).

Rules
- Flat only.
- Diagnostic + cash shot.
- Abort early on hostile start.`,

    "Anti-Last-Dozen (Mean Reversion)":
`Anti-Last-Dozen (CASH)

Score driver
- Rotational / flat table.

Rules
- Conservative ladder.
- Hard abort on ladder failure.
- CASH only if it qualifies (rank #1, score ≥ 85).`,

    "Disappearing Streets (Anti-Repeat)":
`Disappearing Streets (CASH)

Score driver
- No repeat streets + flat table.

Rules
- Remove winners.
- Abort if repeats emerge.`,

    "6 Diamonds (Corner Core)":
`6 Diamonds (Corner Core) — FIXED CORNERS

Corners (fixed 6)
- 1/2/3/5
- 7/8/9/11
- 13/14/15/17
- 19/20/21/23
- 25/26/27/29
- 31/32/33/35

How to bet
- Flat bet 1 unit per corner (your unit size).
- 6 corners total.

Progression (simple, session-safe)
- After a losing spin: +1 unit to ALL 6 corners.
- After a winning spin: −1 unit to ALL 6 corners (minimum 1 unit).

Stop/Reset
- Reset to 1 unit when you’re back near session high, or after any strong recovery.`,

    "Hot Quadrant last-15 (Option A)":
`Hot Quadrant last-15 (Option A)

Trigger
- In last 15 spins, one Junko quadrant has >= 6 hits.

How to bet
- Bet 1 unit on 5 numbers inside the hottest quadrant.
- Optional: if repeats are present, add 2 neighbor numbers inside that quadrant.

Exit / Reset
- If the hot quadrant drops below 6/15, stop and re-evaluate.
- Reset to base on any meaningful recovery (near session high).`,

    "Junko Quadrants (hot/dry)":
`Junko Quadrants (hot/dry)

Quadrants
- GN: 00, 0, 1, 2, 9, 10, 13, 14, 27, 28
- HO: 24,25,26,29,30,33,34,35,36
- LO: 3,4,8,11,12,15,16,22,23
- M: 5,6,7,17,18,19,20,21,31,32

How to use
- If HOT: bet a subset of numbers inside the hottest quadrant (5–7 numbers).
- If DRY: avoid the driest quadrant and play outside it with your preferred structure.

Exit
- Recompute every spin based on last-15 window.`,

    "DS Cash Power":
`DS Cash Power (summary)

Entry
- Based on last-15: in each dozen, identify the hottest double street (6-line).

Bets (base example)
- 3 double streets (one per dozen): 1 unit each.
- Optional corner scaffold per your DSCP variant.

Progression
- Use your DSCP progression rule (step after consecutive losses).
- Reset when near session high.`,

    "Moving Streets (Adjacent Fade)":
`Moving Streets (Adjacent Fade)

Entry
- ONLY when there are NO repeat streets in the last 5 spins (dispersion / choppy).

Rule
- Look at the last 3 streets that hit (convert each number to its street).
- DO NOT bet those 3 streets.
- Instead, bet the adjacent street(s) next to each of those streets.
  Example: if Street 6 hit, adjacent are Streets 5 and 7.
- Merge duplicates; keep total streets reasonable (6–8 streets typical).

Exit
- If street repeats begin (repeat streets flag turns on), stop and switch strategies.`,

    "Sit out":
`Sit out
- Keep logging spins until a repeat or concentration appears.`
  
    ,
    "Corners + Double Streets (Follow the Leader — Locked Until Loss)":
`Corners + Double Streets (Follow the Leader — Locked Until Loss)

Category: CASH / Grind
Wheel: American
Table requirement: $10 table allowing ≥ $15 total inside bets.

Base (Level 1) — TOTAL $16 inside
- Double Streets: 4 adjacent non-overlapping double streets × $3 = $12
- Corners: 4 paired corners × $1 = $4

Double Street ↔ Corner pairings
- 1–6   → corner 2/6   (2,3,5,6)
- 7–12  → corner 8/12  (8,9,11,12)
- 13–18 → corner 14/18 (14,15,17,18)
- 19–24 → corner 20/24 (20,21,23,24)
- 25–30 → corner 26/30 (26,27,29,30)
- 31–36 → corner 32/36 (32,33,35,36)

How to select the DS block (FOLLOW THE LEADER)
1) Look at the previous 2 spins (ignore 0/00).
2) Identify their double streets (one of the 6 DS above).
3) Choose a block of 4 ADJACENT double streets that includes both if possible.
   If not possible, include the most recent spin’s double street.
4) LOCK this DS block until a LOSS occurs.

Numbers to bet (depends on the locked DS block)
- Bet the 4 double streets in your locked block (all numbers inside them).
- Also bet the matching 4 corners for those same 4 double streets.

Progression (multiplier m)
- Start m = 1.
- Increase m by +1 after every 2 consecutive losses.
- Ladder down m by −1 after any win (min m = 1).

Bet sizing at level m
- Double Street bet = $3 × m (each of the 4 double streets)
- Corner bet       = $1 × m (each of the 4 corners)

Reset
- Reset to m=1 when session profit ≥ $30.
- Reset clears loss counter.
- DS block remains unless the NEXT spin is a loss.

Session rules
- Cashout: +$50
- Stop-loss: −$300 (end session immediately).`,
    "Moon Dance 2S/Dozen (Junko Base)":
`Moon Dance 2S/Dozen — Junko Base (CASH)

Core idea
- For each dozen, pick the 2 least-hit streets in the prior 15 spins.
- That yields 6 streets = 18 numbers (straight-up coverage).

Bet
- Bet $b on each of the 18 numbers.
- Start b=1; on a full miss (no 18-hit and no 0/00): b doubles.
- Win if any of the 18 hits OR 0/00 hits: reset b=1 and recompute streets next cycle.

0/00 bailout
- Only when b >= 8: add $2 on 0 and $2 on 00.

Exits
- Cash out +$100 (after spin), stop loss −$200 with guardrail.`,

    "Trinity–Junko v2":
`Trinity–Junko v2 (CASH)

Double Streets
- Bet DS 1–6 and 7–12 (two 6-lines).
- ds_unit starts 1; +1 each spin with NO DS hit; cap 5.
- If any DS hits (1–12): remove BOTH DS until next reset; ds_unit=1.

Corners (8)
- 13/17, 14/18, 19/23, 20/24, 25/29, 26/30, 31/35, 32/36
- Remove any corner(s) that hit.
- corner_unit doubles every 3 spins (win or loss); cap 16.

Resets
- Reset DS+corners+units at +$15 milestones (15/30/45/60/75/90) OR when ≤2 corners remain.

Exits
- Cashout +$90 (after spin), stop loss −$200 with guardrail.`,

    "Opposite-Segment Contrarian (Option 1)":
`Opposite-Segment Contrarian (CASH)

Segments (00 encoded as 99 in data)
A = 13, 1, 00, 27, 10, 9, 28, 0, 2, 14
B = 31, 18, 6, 21, 33, 17, 5, 22, 32, 20
C = 25, 29, 12, 8, 19, 26, 30, 11, 7
D = 36, 24, 3, 15, 34, 35, 23, 4, 16
Opposite: A↔C, B↔D

Entry
- When hottest segment in last-15 has >= 6 hits, bet the opposite segment.

Bet
- $u per number in the bet segment.
- Escalation: +1u after 3 consecutive losing bet-spins.

Exits
- Cashout +$100 (after spin), stop loss −$200 with guardrail.`,

    "Corners + Double Streets (Follow the Leader)":
`Corners + Double Streets — Follow the Leader (CASH/GRIND)

Base (Level 1)
- 4 adjacent DS × $3 each + paired corners × $1 each.

Pairings
1–6→2/6 (2,3,5,6)
7–12→8/12 (8,9,11,12)
13–18→14/18 (14,15,17,18)
19–24→20/24 (20,21,23,24)
25–30→26/30 (26,27,29,30)
31–36→32/36 (32,33,35,36)

Selection
- Use previous 2 spins to select a 4-DS adjacent block that includes both if possible; else include the most recent.
- LOCK DS block until a loss; recalc only after a losing spin.

Progression
- Multiplier m starts 1; +1 after every 2 consecutive losses.
- Ladder down m −1 after any win (min 1).
- Bets: DS=$3*m, corners=$1*m.

Exits
- Cashout +$50, stop loss −$300.`,

    "CASH — Vegas Special C2–C3 Splits": `Vegas Special — C2–C3 Splits (L1–L3)

Trigger
- Requires 15 spins of history (greens allowed, but ignored for street counts).
- Select 7 coldest streets (fewest hits in last 15; tie-break: least-recent hit; then lowest street id).

Bets (by level)
- L1: C2–C3 split on each selected street (1u each).
- L2: Add the full street on each selected street (2u each) in addition to splits.
- L3: Add both straight-up numbers from each split (1u each) in addition to L1+L2.

Progression
- No hit → level up (max L3).
- Any hit → reset to L1 and reselect streets from the next 15-spin window.

Exits
- Cashout +20u, Stoploss −100u (hit-and-run profile).
- Green (0/00) counts as a miss (not covered).`,


    "Easy Street — Cold Side (Option A′ Late Straights)":
`Easy Street — Cold Side (Option A′ Late Straights)

Entry (choose side from last 15 spins)
- Convert each of the last 15 outcomes to its street (1–12). Ignore 0/00.
- Count hits on ODD streets (1,3,5,7,9,11) vs EVEN streets (2,4,6,8,10,12).
- Select the colder side (fewer hits). Tie → ODD.

Main bet (streets)
- Bet 1 unit on ALL 6 streets in the chosen side.
  Odd streets: 1–3, 7–9, 13–15, 19–21, 25–27, 31–33
  Even streets: 4–6, 10–12, 16–18, 22–24, 28–30, 34–36

Progression (streets)
- After a losing spin: increase street unit by +1.
- After any win: reset street unit to 1.

Removal rule (Option A — Dozen Clear)
- If a street hits, remove ALL streets that are in that same dozen.
  (D1: streets 1–4, D2: streets 5–8, D3: streets 9–12)

Late straights add-on (only when ≤2 streets remain AND not yet at cashout)
- Bet 1 unit straight-up on all 3 numbers in each remaining street.
- Increase straight unit by +1 every 5 straight-up losses.
- Reset straight unit to 1 on any win.

Session targets (tested)
- Cashout +20 units
- Stop-loss −50 units
- Auto-reset/reselect at +10 units (recompute cold side and restart units)`

    ,

    "12 Soldiers — Unique Columns, 12→8 Reset":
`12 Soldiers — Unique Columns, 12→8 Reset (SOLDIERS_UC_HYBRID_R1)

Wheel
• American (0+00). Treat 0/00 as losses and never include them in bets.

Entry
• Warmup: log 15 spins (selection only; no bets).

Selection (new session only; locked for the session)
Using the last 15 spins (ignore 0/00 for counts):
1) Dozen 1: pick the driest vertical column-of-4 (min hits; tiebreak = oldest last hit).
2) Dozen 2: pick the driest among the two remaining column indices (cannot reuse D1’s column index).
3) Dozen 3: use the last unused column index.

This yields 12 numbers total (4 per dozen).

Bet / Phases
Phase A (12 numbers)
• Bet 12 straight-ups.
• On every loss: unit += 1.
• On first qualifying hit (and session PnL still < +20): remove the dozen that hit (12→8), reset unit to 1, enter Phase B.

Phase B (8 numbers)
• Bet the remaining 8 straight-ups.
• On loss: add +1 unit after every 2 consecutive losses (loss #2, #4, #6... since last hit).
• On hit: keep same 8; reset consecutive-loss counter to 0 (unit unchanged).

Session targets
• Cashout: +20u
• Stoploss: −160u

Tracker UI
• The tracker shows the current last-15 selection and D1 “driest” stats under Trend + tracking.`


  };

  function openExplain(title, body) {
    $("expTitle").textContent = title || "Strategy details";
    $("expBody").textContent = body || "";
    $("expModal").style.display = "block";
  }
  function closeExplain() {
    $("expModal").style.display = "none";
  }
  on("expClose", "click", closeExplain);
  on("expBackdrop", "click", closeExplain);

  function showExplain(name) {
    // normalize dynamic names (if ever added later)
    let key = name;
    if (key && key.indexOf("Hot Quadrant")===0) key = "Hot Quadrant last-15 (Option A)";
    const body = STRATEGY_DETAILS[key] || STRATEGY_DETAILS[name] || ("No details available for: " + name);
    openExplain(name, body);
  }

  function save() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        spins, windowN, sessionId, casino: $("casinoInput").value || ""
      }));
    } catch(_) {}
  }

  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(Array.isArray(obj.spins)) {
        spins = obj.spins.map(x => {
          if(!x) return null;
          if(typeof x === "string" || typeof x === "number") return {n:numToKey(x), t:Date.now(), s:1};
          return {n:numToKey(x.n), t:Number(x.t)||Date.now(), s:Number(x.s)||1};
        }).filter(x => x && x.n!==null);
      }
      if([10,15,20].includes(obj.windowN)) windowN = obj.windowN;
      if(Number.isFinite(obj.sessionId)) sessionId = Number(obj.sessionId);
      if(typeof obj.casino === "string") $("casinoInput").value = obj.casino;
    } catch(_) {}
  }

  function windowValues() {
    return spins.slice(0, windowN).map(x => x.n);
  }

  /* === KEYPAD MODULE (LOCKED) — DO NOT EDIT === */

  function buildKeypad() {
    const kbd = $("kbd");
    if (!kbd) return;

    // Debug counter (visible on-page)
    if (!window.__kpCount) window.__kpCount = 0;

    const keys = ["00",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36];
    kbd.innerHTML = "";

    const fire = (k) => {
      // Prevent accidental double-fire on iOS (click after touch)
      const now = Date.now();
      if (!window.__kpLastTap) window.__kpLastTap = 0;
      if (now - window.__kpLastTap < 300) return;
      window.__kpLastTap = now;

      window.__kpCount += 1;
      const dbg = $("kpDebug");
      if (dbg) dbg.textContent = "Keypad taps: " + window.__kpCount;

      addSpin(k);
    };

    keys.forEach(k => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "key";
      b.style.touchAction = "manipulation";  // iOS: favor taps
      b.style.webkitTouchCallout = "none";
      b.style.webkitUserSelect = "none";

      if (k === "00") b.className += " zero";
      if (k === 0) b.className += " green";
      b.textContent = String(k);

      // Most reliable: direct property handlers (less iOS weirdness than addEventListener)
      b.onclick = (e) => { if(e) e.preventDefault(); fire(k); };
      b.onpointerup = (e) => { if(e){ try{e.preventDefault();}catch(_){} } fire(k); };
      b.ontouchstart = (e) => { if(e){ try{e.preventDefault();}catch(_){} } };
      b.ontouchend = (e) => { if(e){ e.preventDefault(); e.stopPropagation(); } fire(k); };

      kbd.appendChild(b);
    });

    // Container-level fallback (in case a browser drops per-button handlers)
    if (!kbd.__delegated) {
      kbd.__delegated = true;
      kbd.addEventListener("click", (e) => {
        const t = e.target;
        if (!t || !t.classList || !t.classList.contains("key")) return;
        const raw = (t.textContent || "").trim();
        if (!raw) return;
        fire(raw === "00" ? "00" : Number(raw));
      }, {capture:true});
    }
  }


  function addSpin(val) {
    const k = numToKey(val);
    if (k===null) return;

    // Settle any pending hedge bet (it was placed for THIS spin)
    if (gsah.pending) {
      const hitGreen = isGreen(k);
      const uBet = Number.isFinite(gsah.pendingU) ? gsah.pendingU : (Number.isFinite(gsah.u) ? gsah.u : 1);

      if (hitGreen) {
        // +17u net on split hit
        gsah.pnlU += (17 * uBet);
        gsah.u = 1;
        gsah.lossCount = 0;
        gsah.betSpins = 0;
        gsah.state = "OFF";
        gsah.cooldown = false;
        gsah.offReason = "Green hit — reset";
        gdc = 0;
      } else {
        gsah.pnlU += (-1 * uBet);
        gsah.lossCount += 1;
        gsah.betSpins += 1;

        // 1/4 linear progression
        if (gsah.lossCount % 4 === 0) {
          gsah.u = Math.min(6, (Number.isFinite(gsah.u) ? gsah.u : 1) + 1);
        }

        // Safety budget
        if (gsah.pnlU <= -12) {
          gsah.state = "OFF";
          gsah.cooldown = true;
          gsah.offReason = "Safety budget hit (≤ −12u)";
        }

        // Time cap: 15 hedge bet-spins without green hit
        if (gsah.state !== "OFF" && gsah.betSpins >= 15) {
          gsah.state = "OFF";
          gsah.cooldown = true;
          gsah.offReason = "15 hedge bets w/o green";
        }

        // Cap rule: if at u=6 and completed another full 4-loss cycle, turn off
        if (gsah.state !== "OFF" && gsah.u >= 6 && (gsah.lossCount % 4 === 0)) {
          gsah.state = "OFF";
          gsah.cooldown = true;
          gsah.offReason = "U6 full loss cycle";
        }
      }

      gsah.pending = false;
    }

    // Update green drought counter (if not already reset by hedge win)
    if (isGreen(k)) {
      gdc = 0;
      gsah.cooldown = false;
    } else {
      gdc = (Number.isFinite(gdc) ? gdc : 0) + 1;
    }

    spins.unshift({ n:k, t:Date.now(), s:sessionId });
    if (spins.length > 5000) spins = spins.slice(0, 5000);
    save();
    render();
  }

  function undo() {
    if(spins.length===0) return;
    spins.shift();
    save();
    render();
  }

  function clearAll() {
    if(!confirm("Clear all spins?")) return;
    spins = [];
    sessionId = 1;
    save();
    render();
  }

  function newSession() {
    sessionId += 1;
      gdc = 0;
      gsah = { ...gsah, state:"OFF", cooldown:false, u:1, lossCount:0, betSpins:0, pnlU:0, pending:false, pendingU:1, offReason:"" };
    save();
    render();
  }

  function csvDate(t) {
    const d = new Date(t);
    const yyyy = String(d.getFullYear());
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${yyyy}-${mm}-${dd}`;
  }
  function csvTime(t) {
    const d = new Date(t);
    const hh = String(d.getHours()).padStart(2,'0');
    const mi = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${hh}:${mi}:${ss}`;
  }
  function toCsv() {
    const casino = ($("casinoInput").value||"").replace(/"/g,'""');
    const lines = ["number,casino,date,time,session_id"];
    spins.slice().reverse().forEach(x => {
      const n = (x.n==="00") ? "00" : String(x.n);
      lines.push(`${n},"${casino}",${csvDate(x.t)},${csvTime(x.t)},${x.s}`);
    });
    return lines.join("\n");
  }
  async function copyCsv() {
    const csv = toCsv();
    try {
      await navigator.clipboard.writeText(csv);
      alert("CSV copied.");
    } catch(_) {
      $("lastList").value = csv;
      $("lastList").focus();
      $("lastList").select();
      alert("Clipboard blocked. CSV placed in the box; copy manually.");
    }
  }
  function downloadCsv() {
    const blob = new Blob([toCsv()], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "roulette_spins_ALL.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  // CSV import (append + dedupe)
  function parseCsvLine(line) {
    const out = [];
    let i=0, cur="", inQ=false;
    while(i<line.length) {
      const ch = line.charAt(i);
      if(inQ) {
        if(ch === '"') {
          if(i+1<line.length && line.charAt(i+1)==='"') { cur+='"'; i+=2; continue; }
          inQ=false; i++; continue;
        }
        cur+=ch; i++; continue;
      } else {
        if(ch === '"') { inQ=true; i++; continue; }
        if(ch === ',') { out.push(cur); cur=""; i++; continue; }
        cur+=ch; i++; continue;
      }
    }
    out.push(cur);
    return out;
  }
  function parseNumberCell(cell) {
    const t = String(cell||"").trim();
    if(t==="00") return "00";
    const n = Number(t);
    if(!Number.isFinite(n)) return null;
    if(n===0) return 0;
    if(n>=1 && n<=36) return n;
    return null;
  }
  function parseTimestamp(dateStr, timeStr) {
    const ds = String(dateStr||"").trim();
    const ts = String(timeStr||"").trim();
    const iso = ds + "T" + ts;
    const ms = Date.parse(iso);
    if(Number.isFinite(ms)) return ms;
    // fallback
    const p = ds.split("-");
    const q = ts.split(":");
    if(p.length===3 && q.length>=2) {
      const y=Number(p[0]), m=Number(p[1])-1, d=Number(p[2]);
      const hh=Number(q[0]), mi=Number(q[1]), ss=Number(q[2]||0);
      return new Date(y,m,d,hh,mi,ss).getTime();
    }
    return Date.now();
  }
  function importCsvText(text) {
    const raw = String(text||"").trim();
    if(!raw) return {added:0, skipped:0, msg:"Nothing to import."};
    const lines = raw.split(/\r?\n/).filter(x => String(x).trim().length>0);
    if(lines.length < 2) return {added:0, skipped:0, msg:"CSV needs a header + at least 1 row."};

    let startIdx = 0;
    const h = lines[0].toLowerCase();
    if(h.includes("number") && h.includes("session")) startIdx = 1;

    const seen = new Set(spins.map(x => `${String(x.n)}|${String(x.t)}|${String(x.s)}`));
    let added=0, skipped=0;
    let casinoFromFile = null;

    for(let r=startIdx; r<lines.length; r++) {
      const cols = parseCsvLine(lines[r]);
      if(cols.length < 5) { skipped++; continue; }
      const n = parseNumberCell(cols[0]);
      if(n===null) { skipped++; continue; }
      const casino = String(cols[1]||"").trim();
      if(casino && casinoFromFile===null) casinoFromFile = casino;
      const t = parseTimestamp(cols[2], cols[3]);
      let s = Number(String(cols[4]||"").trim());
      if(!Number.isFinite(s)) s = 1;

      const key = `${String(n)}|${String(t)}|${String(s)}`;
      if(seen.has(key)) { skipped++; continue; }
      spins.push({n,t,s});
      seen.add(key);
      added++;
    }

    spins.sort((a,b)=>b.t-a.t);
    if(casinoFromFile && (!$("casinoInput").value || !$("casinoInput").value.trim())) {
      $("casinoInput").value = casinoFromFile;
    }
    save();
    render();
    return {added, skipped, msg:`Imported ${added} spins (skipped ${skipped}).`};
  }

  // Strategy scoring (simple but consistent with earlier intent)
    // Strategy scoring with CASH/COMP gate (Top 8 CASH). CASH is eligible only if it is #1 overall AND score >= 85.
  // Strategy scoring with CASH priority + suppression.
// CASH is eligible only if the chosen CASH strategy is #1 overall AND score >= 85.
const CASH_PRIORITY = [
  "Moon Dance 2S/Dozen (Junko Base)",
  "12 Soldiers — Unique Columns, 12→8 Reset",
  "Trinity–Junko v2",
  "Opposite-Segment Contrarian (Option 1)",
  "Corners + Double Streets (Follow-the-Leader)",
  "Junko Hot (Quadrant Momentum)",
  "Dirty Bird — Cold Dozen Switch (DB-CDS) [Cash]",
  "SYSTEM — Dirty Bird + WB-RTB",
  "WB-RTB",
  "Easy Street — Cold Side (Option A′ Late Straights)"
];

function streetKey(n){
  const s = streetId(n);
  if(!s) return null;
  // map street number to dozen street index 1..4
  // Streets: 1-4 in dozen1, 5-8 dozen2, 9-12 dozen3 (by street)
  // But we want within-dozen: 1-4, 5-8, 9-12 per dozen in number-space:
  // StreetId already 1..12 with 1=1-3 ... 12=34-36
  const within = ((s-1) % 4) + 1; // 1..4
  const dozen = s<=4 ? 1 : (s<=8 ? 2 : 3);
  return {dozen, within, street: s};
}

function leastTwoStreetsPerDozen(last15){
  const counts = {1:[0,0,0,0], 2:[0,0,0,0], 3:[0,0,0,0]};
  last15.forEach(n=>{
    const k = streetKey(n);
    if(!k) return;
    counts[k.dozen][k.within-1] += 1;
  });

  // Street ranges per dozen (within 1..4)
  const ranges = {
    1: {1:{start:1,end:3,label:"1–3"}, 2:{start:4,end:6,label:"4–6"}, 3:{start:7,end:9,label:"7–9"}, 4:{start:10,end:12,label:"10–12"}},
    2: {1:{start:13,end:15,label:"13–15"}, 2:{start:16,end:18,label:"16–18"}, 3:{start:19,end:21,label:"19–21"}, 4:{start:22,end:24,label:"22–24"}},
    3: {1:{start:25,end:27,label:"25–27"}, 2:{start:28,end:30,label:"28–30"}, 3:{start:31,end:33,label:"31–33"}, 4:{start:34,end:36,label:"34–36"}}
  };

  // pick two least-hit within each dozen; ties -> lower within index
  const picks = {};       // {dozen:[withinIdx, withinIdx]}
  const pickDetail = {};  // {dozen:[{idx, range}, {idx, range}]}

  [1,2,3].forEach(d=>{
    const arr = counts[d].map((c,i)=>({c, idx:i+1}));
    arr.sort((a,b)=> (a.c-b.c) || (a.idx-b.idx));
    picks[d] = [arr[0].idx, arr[1].idx];
    pickDetail[d] = [
      { idx: arr[0].idx, range: ranges[d][arr[0].idx] },
      { idx: arr[1].idx, range: ranges[d][arr[1].idx] }
    ];
  });

  return {counts, picks, pickDetail};
}

function numbersForDozenStreet(dozen, within){
  // within 1..4 for a dozen => streets ranges in number-space
  const base = (dozen-1)*12;
  const start = base + (within-1)*3 + 1;
  return [start,start+1,start+2];
}

function moonDanceNumbers(last15){
  const {picks} = leastTwoStreetsPerDozen(last15);
  const nums = [];
  [1,2,3].forEach(d=>{
    picks[d].forEach(within=>{
      nums.push(...numbersForDozenStreet(d,within));
    });
  });
  return nums; // 18 nums
}

// Opposite-Segment mapping (00 handled as "00" string in this tracker)
const SEG_A = new Set([13,1,"00",27,10,9,28,0,2,14]);
const SEG_B = new Set([31,18,6,21,33,17,5,22,32,20]);
const SEG_C = new Set([25,29,12,8,19,26,30,11,7]);
const SEG_D = new Set([36,24,3,15,34,35,23,4,16]);
const SEG_ORDER = ["A","B","C","D"];
function segmentOf(n){
  const k = (n==="00") ? "00" : Number(n);
  if(SEG_A.has(k)) return "A";
  if(SEG_B.has(k)) return "B";
  if(SEG_C.has(k)) return "C";
  if(SEG_D.has(k)) return "D";
  return null;
}
function oppositeSeg(seg){ return seg==="A"?"C":(seg==="C"?"A":(seg==="B"?"D":"B")); }
function segNumbers(seg){
  const map = {A:[13,1,"00",27,10,9,28,0,2,14], B:[31,18,6,21,33,17,5,22,32,20], C:[25,29,12,8,19,26,30,11,7], D:[36,24,3,15,34,35,23,4,16]};
  return map[seg] || [];
}

function dsRangeOf(n){
  if(n==="00"||n===0) return null;
  const v = Number(n);
  if(!(v>=1 && v<=36)) return null;
  const s = streetId(v); // 1..12
  if(!s) return null;
  const dsStartStreet = (s%2===1) ? s : (s-1); // odd street starts DS
  const a = (dsStartStreet-1)*3 + 1;
  const b = a+5;
  return {start:a, end:b, dsStreetStart: dsStartStreet}; // e.g., 1-6, 7-12, ...
}
function dsKeyLabel(r){ return r ? `${r.start}-${r.end}` : null; }

function cornersForDSRange(label){
  const map = {
    "1-6":[2,3,5,6],
    "7-12":[8,9,11,12],
    "13-18":[14,15,17,18],
    "19-24":[20,21,23,24],
    "25-30":[26,27,29,30],
    "31-36":[32,33,35,36]
  };
  return map[label] || [];
}

function pickFTLBlock(last2){
  if(last2.length<1) return null;
  const d1 = dsKeyLabel(dsRangeOf(last2[0]));
  const d2 = last2.length>=2 ? dsKeyLabel(dsRangeOf(last2[1])) : null;
  const all = ["1-6","7-12","13-18","19-24","25-30","31-36"];
  const idx = (x)=> all.indexOf(x);
  if(!d1) return null;
  if(d2 && idx(d2)!==-1){
    const i1 = idx(d1), i2 = idx(d2);
    const lo = Math.min(i1,i2), hi = Math.max(i1,i2);
    // can we choose 4 adjacent including both?
    // choose window of 4 containing [lo,hi]
    if(hi-lo <= 3){
      let start = Math.max(0, hi-3);
      start = Math.min(start, lo);
      start = Math.min(start, all.length-4);
      return all.slice(start, start+4);
    }
  }
  // fallback: include most recent d1, center window around it
  const i = idx(d1);
  const start = Math.max(0, Math.min(all.length-4, i-1));
  return all.slice(start,start+4);
}

function scoreMoonDance(vals){
  const last15 = vals.slice(0,15);
  if(last15.length<15) return {score:0, why:"Need 15 spins."};
  const {counts, picks, pickDetail} = leastTwoStreetsPerDozen(last15);
  // score higher when depletion is strong: lowest streets very low (0-1 hits)
  const lows = [];
  [1,2,3].forEach(d=>{
    picks[d].forEach(within=>{
      lows.push(counts[d][within-1]);
    });
  });
  const avgLow = lows.reduce((a,b)=>a+b,0)/lows.length;
  const zeros = lows.filter(x=>x===0).length;
  let score = 70 + zeros*6 + Math.max(0, (2-avgLow))*10; // heuristic
  score = Math.max(0, Math.min(99, Math.round(score)));
  const nums = moonDanceNumbers(last15);
  const md = leastTwoStreetsPerDozen(last15);
  const betLines = ["D1","D2","D3"].map(d=>{
    const dd = Number(d.replace("D",""));
    const a = md.pickDetail[dd][0];
    const b = md.pickDetail[dd][1];
    return `${d}: ${a.range.label} & ${b.range.label}`;
  }).join(" | ");
  const betText = `Bet ${betLines} (18 nums)`;
  const detail = [1,2,3].map(d=>{
    const a = md.pickDetail[d][0];
    const b = md.pickDetail[d][1];
    return `D${d}: ${a.range.label} & ${b.range.label} (counts ${md.counts[d][a.idx-1]}/${md.counts[d][b.idx-1]})`;
  }).join(" • ");
  return {score, why:`Least-hit streets identified per dozen (18-number coverage).`, numbers: nums, md_picks: md.picks, md_pickDetail: md.pickDetail, md_counts: md.counts, betText, detail};
}


  
function scoreVegasSpecial(vals){
  // Uses last 15 spins (including greens, but greens don't count toward street hits)
  const arr15 = (vals && Array.isArray(vals.last15)) ? vals.last15.slice(0,15) : [];
  if(arr15.length < 15){
    return { score: 0, why: "Need 15 spins", streets: [], bets: "" };
  }

  const norm = (x)=>{
    if(x===null || x===undefined) return null;
    const s = String(x).trim();
    if(s==="00" || s==="99") return 99;
    if(s==="0") return 0;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  };
  const isGreen = (n)=> (n===0 || n==="00");
  const streetIdOf = (n)=>{
    if(n===null || isGreen(n)) return null;
    if(n<1 || n>36) return null;
    return Math.floor((n-1)/3)+1; // 1..12
  };

  const last15Chron = arr15.map(norm).reverse(); // oldest->newest
  const counts = Array.from({length:13}, ()=>0); // 0 unused
  const lastHit = Array.from({length:13}, ()=>-1);

  last15Chron.forEach((n, idx)=>{
    const sid = streetIdOf(n);
    if(!sid) return;
    counts[sid] += 1;
    lastHit[sid] = idx;
  });

  const streets = Array.from({length:12}, (_,i)=>i+1)
    .sort((a,b)=>{
      if(counts[a]!==counts[b]) return counts[a]-counts[b];
      if(lastHit[a]!==lastHit[b]) return lastHit[a]-lastHit[b];
      return a-b;
    })
    .slice(0,7);

  const zeroHit = streets.filter(s=>counts[s]===0).length;
  let score = 70;
  if(zeroHit>=5) score = 88;
  else if(zeroHit>=3) score = 82;
  else if(zeroHit>=1) score = 76;

  const splitPairs = streets.map(s=>{
    // C2-C3 split per street = (3*s-1, 3*s)
    const a = 3*s-1, b = 3*s;
    return `${a}|${b}`;
  });

  const why = `Coldest 7 streets (last15): S${streets.join(",S")} • zero-hit=${zeroHit}`;
  const bets = `L1: 7 splits (${splitPairs.join(", ")})`;

  return { score, why, streets, bets };
}

function scoreOppSeg(vals){
  const last15 = vals.slice(0,15);
  if(last15.length<15) return {score:0, why:"Need 15 spins."};
  const counts = {A:0,B:0,C:0,D:0};
  last15.forEach(n=>{
    const s = segmentOf(n);
    if(s) counts[s]+=1;
  });
  // tie-break A->B->C->D
  let hottest = "A";
  SEG_ORDER.forEach(seg=>{
    if(counts[seg] > counts[hottest]) hottest = seg;
  });
  const hotCount = counts[hottest];
  let score = 55 + Math.max(0, hotCount-4)*10; // 5->65, 6->75, 7->85...
  if(hotCount>=6) score += 10;
  score = Math.max(0, Math.min(99, Math.round(score)));
  const betSeg = oppositeSeg(hottest);
  return {score, why:`Hottest segment ${hottest}=${hotCount}/15 → bet opposite ${betSeg}.`, numbers: segNumbers(betSeg)};
}

function scoreFTL(vals){
  if(vals.length<3) return {score:0, why:"Need at least 3 spins."};
  const last2 = vals.slice(0,2);
  const block = pickFTLBlock(last2);
  if(!block) return {score:0, why:"No DS mapping."};
  // score higher if last 6 contains hits inside block
  const last15 = vals.slice(0,15);
  const inBlock = (n)=>{
    if(n==="00"||n===0) return false;
    const v = Number(n);
    for(const lbl of block){
      const [a,b]=lbl.split("-").map(Number);
      if(v>=a && v<=b) return true;
    }
    return false;
  };
  const hit6 = last15.slice(0,6).filter(inBlock).length;
  const hit15 = last15.filter(inBlock).length;
  let score = 60 + hit6*5 + Math.max(0, hit15-6)*2;
  score = Math.max(0, Math.min(95, Math.round(score)));
  // numbers to bet: all DS numbers plus corners mapped per DS
  const nums = [];
  block.forEach(lbl=>{
    const [a,b]=lbl.split("-").map(Number);
    for(let x=a;x<=b;x++) nums.push(x);
    nums.push(...cornersForDSRange(lbl));
  });
  const uniq = Array.from(new Set(nums)).sort((a,b)=>a-b);
  return {score, why:`Follow last 2 spins → DS block ${block.join(", ")} (locked until loss).`, block, numbers: uniq};
}

function scoreJunkoHot(vals){
  const last15 = vals.slice(0,15);
  const c15 = counts(last15);
  const qMax = Math.max(c15.gn,c15.ho,c15.lo,c15.m);
  let score = 55 + Math.max(0, qMax-4)*10; // 5->65,6->75,7->85
  if(qMax>=6) score += 10;
  score = Math.max(0, Math.min(95, Math.round(score)));
  return {score, why:`Junko quadrant momentum: max ${qMax}/15.`, numbers: []};
}

function scoreSlowSteady(vals){
  const last15 = vals.slice(0,15);
  const c15 = counts(last15);
  const dozMax = Math.max(c15.d1,c15.d2,c15.d3);
  const colMax = Math.max(c15.c1,c15.c2,c15.c3);
  let score = 50 + Math.max(dozMax, colMax)*4;
  score = Math.max(0, Math.min(90, Math.round(score)));
  return {score, why:`Structural bias: Dozen max ${dozMax}/15, Column max ${colMax}/15.`, numbers: []};
}


  function scoreEasyStreet(vals){
    const w15 = vals.slice(0,15);
    if(w15.length < 15) return null;

    const ODD = new Set([1,3,5,7,9,11]);
    const EVEN = new Set([2,4,6,8,10,12]);

    let oddHits=0, evenHits=0;
    w15.forEach((n)=>{
      const sid = streetId(n);
      if(!sid) return;
      if(ODD.has(sid)) oddHits++;
      if(EVEN.has(sid)) evenHits++;
    });

    const coldSide = (oddHits <= evenHits) ? "ODD" : "EVEN";
    const diff = Math.abs(oddHits - evenHits);

    const streets = (coldSide==="ODD") ? [1,3,5,7,9,11] : [2,4,6,8,10,12];

    // Build numbers for quick bet visualization
    const nums = [];
    streets.forEach(s=>{
      const a = (s-1)*3 + 1;
      nums.push(a, a+1, a+2);
    });

    // Scoring heuristic: only a mild edge signal; best when imbalance is clear
    let score = 74;
    if(diff >= 3) score = 84;
    if(diff >= 5) score = 88;

    const why = `Cold side ${coldSide} (odd ${oddHits}/15 vs even ${evenHits}/15). Streets: ${streets.join(", ")}.`;

    return {name:"Easy Street — Cold Side (Option A′ Late Straights)", score, why, streets, numbers:nums};
  }


/* ============================================================
   BET PACK STRATEGIES (v15.3.2.1)
   - Dirty Bird DB-CDS (Cash + Comp)
   - WB-RTB
   - SYSTEM_DB_WB selector
   - Easy Street A′
   - Trinity v2 (Independent Modules)
   ============================================================ */

function dzOf(n){
  if(n>=1 && n<=12) return 1;
  if(n>=13 && n<=24) return 2;
  if(n>=25 && n<=36) return 3;
  return null;
}
function lastNNoGreen(valsNewestFirst, N){
  const out=[];
  for(const v of valsNewestFirst){
    if(v===0||v==="00") continue;
    out.push(v);
    if(out.length>=N) break;
  }
  return out; // newest-first
}
function dozenCounts15(vals){
  const w = lastNNoGreen(vals,15);
  if(w.length<15) return null;
  const c={D1:0,D2:0,D3:0};
  for(const n of w){
    const dz=dzOf(n);
    if(dz===1) c.D1++;
    else if(dz===2) c.D2++;
    else if(dz===3) c.D3++;
  }
  return c;
}
function pickDozenMin(counts){
  // tiebreak D1 > D2 > D3 (prefer lower dozen)
  let best="D1"; let min=counts.D1;
  if(counts.D2<min){min=counts.D2; best="D2";}
  if(counts.D3<min){min=counts.D3; best="D3";}
  return best;
}
function pickDozenMax(counts){
  let best="D1"; let mx=counts.D1;
  if(counts.D2>mx){mx=counts.D2; best="D2";}
  if(counts.D3>mx){mx=counts.D3; best="D3";}
  return best;
}
function dozenNums(dzKey){
  const dz = (dzKey==="D1")?1:(dzKey==="D2")?2:3;
  const min = dz===1?1:dz===2?13:25;
  const max = dz===1?12:dz===2?24:36;
  const a=[]; for(let i=min;i<=max;i++) a.push(i);
  return a;
}
function countNumsInDozen(valsNewestFirst, dzKey){
  const nums = dozenNums(dzKey);
  const map={}; for(const n of nums) map[n]=0;
  const w = lastNNoGreen(valsNewestFirst,15);
  for(const n of w){
    if(dzOf(n)=== (dzKey==="D1"?1:dzKey==="D2"?2:3)) map[n]=(map[n]||0)+1;
  }
  return map;
}
function twoColdest(map){
  const e = Object.entries(map).map(([k,v])=>({n:+k,c:v}));
  e.sort((a,b)=>(a.c-b.c)||(a.n-b.n));
  return [e[0].n,e[1].n];
}
function twoHottest(map){
  const e = Object.entries(map).map(([k,v])=>({n:+k,c:v}));
  e.sort((a,b)=>(b.c-a.c)||(a.n-b.n));
  return [e[0].n,e[1].n];
}
function gapCounts(counts){
  return Math.max(counts.D1,counts.D2,counts.D3) - Math.min(counts.D1,counts.D2,counts.D3);
}

function scoreDBCDS(vals, variant /*"cash"|"comp"*/){
  const w = lastNNoGreen(vals,15);
  if(w.length<15) return {score:1, why:"Warmup: need 15 non-green spins.", picks:null};

  const counts = dozenCounts15(vals);
  const coldDz = pickDozenMin(counts);
  const coldHits = counts[coldDz];
  const g = gapCounts(counts);

  // mode resolution (stateless; based on current window only)
  let mode = "COLD";
  if(coldHits<=3) mode="SWITCH";
  if(mode==="SWITCH" && g<=2) mode="COLD"; // immediate exit if already balanced

  const chosenDz = (mode==="COLD") ? coldDz : pickDozenMax(counts);
  const numCounts = countNumsInDozen(vals, chosenDz);
  const excl = (mode==="COLD") ? twoColdest(numCounts) : twoHottest(numCounts);
  const nums = dozenNums(chosenDz).filter(n=>!excl.includes(n));

  const scoreBase = (mode==="SWITCH") ? 86 : 84;
  const score = scoreBase + Math.min(10, Math.max(0, (5 - Math.abs(g-3)))); // mild bump when structure exists

  const cashout = (variant==="comp")?60:100;
  const stop = (variant==="comp")?-300:-200;

  return {
    score,
    why:`Mode=${mode}. ${chosenDz} selected. DozenCounts last15 (no green): D1:${counts.D1} D2:${counts.D2} D3:${counts.D3}.`,
    picks:{
      mode,
      dozen: chosenDz,
      exclude: excl,
      numbers: nums,
      stake_u: 10, // × uLevel (tracker-level)
      cashout,
      stop
    },
    betText:`Bet ${chosenDz} (10 numbers), leave off ${excl.join(", ")}.`
  };
}

/* WB-RTB (entry + bet amounts at k=0; tracker can extend progression if desired) */
function scoreWBRTB(vals){
  if(vals.length < 20) return {score:1, why:"Warmup: need 20 spins.", picks:null};
  const w20 = vals.slice(0,20).filter(v=>v!==0 && v!==99);
  if(w20.length < 16) return {score:10, why:"Need more non-green spins in last 20.", picks:null};

  let scoreLow=0, scoreHigh=0;
  for(const n of w20){
    if(n>=1 && n<=18) scoreLow++;
    if(n>=1 && n<=12) scoreLow++;
    if(n>=19 && n<=36) scoreHigh++;
    if(n>=25 && n<=36) scoreHigh++;
  }
  const lead = Math.abs(scoreLow - scoreHigh);
  if(lead < 3) return {score:20, why:`No entry: lead=${lead} (<3).`, picks:null};

  const leader = (scoreLow>scoreHigh) ? "LOW" : "HIGH";
  const outside = leader==="LOW" ? "LOW (1–18)" : "HIGH (19–36)";
  const dozen = leader==="LOW" ? "D1 (1–12)" : "D3 (25–36)";
  const k=0;
  const outsideStake=10*(2**k);
  const dozenStake=5*(2**k);
  const totalStake=outsideStake+dozenStake;

  return {
    score:90,
    why:`Entry ON: leader=${leader}, lead=${lead}. Burst=2 spins.`,
    picks:{leader, outside, dozen, k_level:k, outsideStake, dozenStake, totalStake},
    betText:`Bet ${outsideStake}u on ${outside} AND ${dozenStake}u on ${dozen} (k=${k}).`
  };
}

/* SYSTEM selector: HOSTILE / STRUCTURED / CHOPPY */
function repeatNumberInfo(valsNewestFirst, within=5){
  const v = valsNewestFirst.slice(0, Math.min(20, valsNewestFirst.length));
  const seen = new Map();
  let repeats=0;
  for(let i=0;i<v.length;i++){
    const n=v[i];
    if(n===0||n==="00") continue;
    if(seen.has(n) && (seen.get(n)-i)<=within) repeats++;
    seen.set(n,i);
  }
  return {repeats, flag: repeats>=2};
}
function classifySystemDBWB(vals){
  const v20 = vals.slice(0,20);
  const greens = v20.filter(v=>(v===0 || v==="00")).length;

  // dozen "gap" proxy: if any dozen absent in last 20 => treat as large gap
  const seen={D1:false,D2:false,D3:false};
  for(const n of v20){
    if(n===0||n==="00") continue;
    const dz=dzOf(n);
    if(dz===1) seen.D1=true;
    if(dz===2) seen.D2=true;
    if(dz===3) seen.D3=true;
  }
  const missingDozen = (!seen.D1)||(!seen.D2)||(!seen.D3);

  if(greens>=3 || missingDozen){
    return {state:"HOSTILE", reasons:[greens>=3?`greens>=3 (last20=${greens})`:null, missingDozen?`a dozen missing in last20`:null].filter(Boolean)};
  }

  const rn = repeatNumberInfo(vals,5);
  const c15 = dozenCounts15(vals) || {D1:0,D2:0,D3:0};
  const dozBias = Math.max(c15.D1,c15.D2,c15.D3) >= 6;

  let low=0, high=0, even=0, odd=0;
  for(const n of v20){
    if(n===0||n==="00") continue;
    if(n<=18) low++; else high++;
    if(n%2===0) even++; else odd++;
  }
  const outBias = Math.max(low,high) / Math.max(1,(low+high)) >= 0.60;
  const parBias = Math.max(even,odd) / Math.max(1,(even+odd)) >= 0.60;

  function altRate(seq){
    let flips=0, tot=0;
    for(let i=1;i<seq.length;i++){
      if(seq[i]===null||seq[i-1]===null) continue;
      tot++;
      if(seq[i]!==seq[i-1]) flips++;
    }
    return tot? (flips/tot):0;
  }
  const lhSeq = v20.map(n => (n===0||n==="00")?null:(Number(n)<=18?"L":"H"));
  const eoSeq = v20.map(n => (n===0||n==="00")?null:((Number(n)%2===0)?"E":"O"));
  const choppy = (altRate(lhSeq)>=0.70) || (altRate(eoSeq)>=0.70);

  const signals = [rn.flag, dozBias, outBias, parBias].filter(Boolean).length;
  if(!choppy && signals>=2){
    return {state:"STRUCTURED", reasons:[
      rn.flag?`repeat numbers` : null,
      dozBias?`dozen bias` : null,
      outBias?`outside bias` : null,
      parBias?`parity bias` : null
    ].filter(Boolean)};
  }
  return {state:"CHOPPY", reasons:[choppy?`high alternation`:`insufficient structure`]};
}
function scoreSystemDBWB(vals){
  if(vals.length < 15) return {score:1, why:"Warmup: need 15 spins.", picks:null};
  const cls = classifySystemDBWB(vals);
  if(cls.state==="HOSTILE"){
    return {score:5, why:`HOSTILE → NO PLAY (${cls.reasons.join("; ")})`, picks:{table_state:cls.state, reasons:cls.reasons}, betText:"No play."};
  }
  if(cls.state==="STRUCTURED"){
    const db = scoreDBCDS(vals,"cash");
    return {score:Math.max(1, db.score-2), why:`STRUCTURED → Dirty Bird (${cls.reasons.join("; ")})`, picks:{table_state:cls.state, reasons:cls.reasons, module:"DIRTY_BIRD", moduleBet:db.picks}, betText:`Dirty Bird: ${db.betText}`};
  }
  const wb = scoreWBRTB(vals);
  return {score:Math.max(1, wb.score-2), why:`CHOPPY → WB-RTB (${cls.reasons.join("; ")})`, picks:{table_state:cls.state, reasons:cls.reasons, module:"WB_RTB", moduleBet:wb.picks}, betText:`WB-RTB: ${wb.betText||"SIT OUT"}`};
}

/* Easy Street — Cold Side (Option A′ Late Straights): show side + base streets (no late-stage removal sim). */
function scoreEasyStreetA(vals){
  if(vals.length < 15) return {score:1, why:"Warmup: need 15 spins.", picks:null};
  const v15 = vals.slice(0,15).filter(v=>v!==0 && v!==99);
  if(v15.length < 12) return {score:10, why:"Need more non-green spins in last 15.", picks:null};

  const oddSt=[1,3,5,7,9,11], evenSt=[2,4,6,8,10,12];
  const stCount = {odd:0, even:0};
  for(const n of v15){
    const sid = Math.floor((n-1)/3)+1;
    if(oddSt.includes(sid)) stCount.odd++;
    else stCount.even++;
  }
  const side = (stCount.odd<=stCount.even) ? "ODD" : "EVEN";
  const gap = Math.abs(stCount.odd-stCount.even);
  const score = 70 + Math.min(20, gap*4);
  const streets = (side==="ODD")?oddSt:evenSt;
  return {score, why:`Cold side=${side} (oddHits=${stCount.odd}, evenHits=${stCount.even}).`, picks:{side, streets, streetU:1, stake_u:6}, betText:`Bet streets ${streets.join(", ")} @ 1u each (total 6u).`};
}

/* Trinity v2: fixed corners + hedge info (simplified; no PnL enforcement) */
function scoreTrinityV2(vals){
  if(vals.length < 15) return {score:1, why:"Warmup: need 15 spins.", picks:null};
  const corners = [
    [13,14,16,17],[14,15,17,18],[19,20,22,23],[20,21,23,24],
    [25,26,28,29],[26,27,29,30],[31,32,34,35],[32,33,35,36],
  ];
  // Estimate mainU by spins beyond warmup: +1 every 3 spins (cap 8)
  const spinsBeyond = Math.max(0, vals.length-15);
  const mainU = Math.min(8, 1 + Math.floor(spinsBeyond/3));

  return {
    score:78,
    why:`MainU≈${mainU} (every 3 spins +1, cap 8). Hedge runs until first hit on 1–12.`,
    picks:{mainU, corners},
    betText:`Main: 8 fixed corners @ ${mainU}u. Hedge: 1–6 and 7–12 six-lines (until first hit).`
  };
}

// Compatibility alias: older scorer name used by registry
function scoreTrinity(vals){
  return scoreTrinityV2(vals);
}

function scoreStrategies(vals) {
  const plays = [];
  const add = (name, score, why, extra={}) => plays.push({name, score, why, ...extra});

  // Fail-safe: a broken strategy must never crash render/keypad.
  const safe = (name, fn) => {
    try { return fn(); }
    catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      add(name, 0, `ERROR: ${msg}`, {error:true});
      return null;
    }
  };


  // Base COMP always present
      const vs = safe("CASH — Vegas Special C2–C3 Splits (L1–L3)", () => scoreVegasSpecial(vals));
  if(vs) add("CASH — Vegas Special C2–C3 Splits (L1–L3)", vs.score, vs.why, {bets: vs.bets});
  add("6 Diamonds + 0/00 (Primary)", 70, "Default COMP coverage / survivability.");

  const md = safe("Moon Dance 2S/Dozen (Junko Base)", () => scoreMoonDance(vals));
  if(md) add("Moon Dance 2S/Dozen (Junko Base)", md.score, md.why, {numbers: md.numbers});

  // 12 Soldiers — Unique Columns, 12→8 Reset (selection + score)
  const sld = safe("12 Soldiers — Unique Columns, 12→8 Reset", () => {
    const st = soldiersStatsLast15(vals);
    if(!st.ok) return {score:0, why: st.msg || "Need 15 spins.", numbers: []};
    const last15 = vals.slice(0,15).reverse(); // oldest->newest
    const counts = new Map();
    for(const x of last15){
      const n = soldiersNormalizeSpin(x);
      if(n == null || soldiersIsGreen(n)) continue;
      counts.set(n, (counts.get(n)||0)+1);
    }
    const nums = [...st.D1_Numbers, ...st.D2_Numbers, ...st.D3_Numbers];
    const totalHits = nums.reduce((a,n)=>a+(counts.get(n)||0),0);
    const age = st.STAT_D1_DriestColSpinsSinceLastHit_L15;
    // Heuristic: colder selection (fewer hits) + older D1 column => higher score.
    let score = 99 - (totalHits*3) + Math.min(8, Math.max(0, age-4));
    score = Math.max(70, Math.min(99, score));
    const why = `12-number cold column grid. Total hits L15=${totalHits}; D1 age=${age}.`;
    return {score, why, numbers: nums};
  });
  if(sld) add("12 Soldiers — Unique Columns, 12→8 Reset", sld.score, sld.why, {numbers: sld.numbers});
  const tr = safe("Trinity–Junko v2", () => scoreTrinity(vals));
  if(tr) add("Trinity–Junko v2", tr.score, tr.why, {numbers: tr.numbers});
  const os = safe("Opposite-Segment Contrarian (Option 1)", () => scoreOppSeg(vals));
  if(os) add("Opposite-Segment Contrarian (Option 1)", os.score, os.why, {numbers: os.numbers});
  const ftl = safe("Corners + Double Streets (Follow the Leader)", () => scoreFTL(vals));
  if(ftl) add("Corners + Double Streets (Follow the Leader)", ftl.score, ftl.why, {numbers: ftl.numbers, block: ftl.block});
  const jh = safe("Junko Hot (Quadrant Momentum)", () => scoreJunkoHot(vals));
  if(jh) add("Junko Hot (Quadrant Momentum)", jh.score, jh.why);
  const ss = safe("Slow & Steady (Structural Bias)", () => scoreSlowSteady(vals));
  if(ss) add("Slow & Steady (Structural Bias)", ss.score, ss.why);

  // BET PACK additions
  const dbCash = safe("Dirty Bird — Cold Dozen Switch (DB-CDS) [Cash]", () => scoreDBCDS(vals,"cash"));
  if(dbCash) add("Dirty Bird — Cold Dozen Switch (DB-CDS) [Cash]", dbCash.score, dbCash.why, {bets: dbCash.picks, betText: dbCash.betText});
  const dbComp = safe("Dirty Bird — Cold Dozen Switch (DB-CDS) [Comp]", () => scoreDBCDS(vals,"comp"));
  if(dbComp) add("Dirty Bird — Cold Dozen Switch (DB-CDS) [Comp]", dbComp.score-2, dbComp.why, {bets: dbComp.picks, betText: dbComp.betText});
  const wb = safe("WB-RTB", () => scoreWBRTB(vals));
  if(wb) add("WB-RTB", wb.score, wb.why, {bets: wb.picks, betText: wb.betText});
  const sys = safe("SYSTEM — Dirty Bird + WB-RTB", () => scoreSystemDBWB(vals));
  if(sys) add("SYSTEM — Dirty Bird + WB-RTB", sys.score, sys.why, {bets: sys.picks, betText: sys.betText});
  const es = safe("Easy Street — Cold Side (Option A′ Late Straights)", () => scoreEasyStreetA(vals));
  if(es) add("Easy Street — Cold Side (Option A′ Late Straights)", es.score, es.why, {bets: es.picks, betText: es.betText});
  const tv2 = safe("Trinity v2 (Independent Modules)", () => scoreTrinityV2(vals));
  if(tv2) add("Trinity v2 (Independent Modules)", tv2.score, tv2.why, {bets: tv2.picks, betText: tv2.betText});



  // Annotate play mode for display (COMP vs CASH)
  plays.forEach(p => {
    if (p && !p.mode) {
      const nm = String(p.name || "");
      const isCash = nm.startsWith("CASH —") || nm.includes("[Cash]") || CASH_PRIORITY.includes(nm);
      p.mode = isCash ? "CASH" : "COMP";
    }
  });

  // Sort by score for display
  plays.sort((a,b)=>b.score-a.score);
  const top3 = plays.slice(0,3);

  // Determine active recommendation with CASH priority rule
  let primary = top3[0] || {name:"Sit out", score:1, why:"No clear edge."};

  // CASH gate: choose among CASH-eligible (score>=85) using priority order.
  const eligible = plays.filter(p => p.score >= 85 && CASH_PRIORITY.includes(p.name));
  let chosenCash = null;
  if(eligible.length){
    for(const nm of CASH_PRIORITY){
      const p = eligible.find(x => x.name === nm);
      if(p){ chosenCash = p; break; }
    }
  }
  // If chosenCash exists, it becomes primary only if it's also #1 overall (per operating spec).
  if(chosenCash && plays[0] && plays[0].name === chosenCash.name){
    primary = chosenCash;
    primary.mode = "CASH";
  } else {
    primary.mode = "COMP";
    // If table unclear/no data, stay COMP.
    if(vals.length < 10){
      primary = {name:"Sit out", score:1, why:"Log at least 10 spins for trend signals.", mode:"COMP"};
    } else if(primary.name !== "6 Diamonds + 0/00 (Primary)" && primary.score < 85){
      primary = plays.find(p=>p.name==="6 Diamonds + 0/00 (Primary)") || primary;
      primary.mode = "COMP";
    }
  }

  // Table state simple
  const rn = repeatNumberInfo(vals, 5);
  const rs3 = repeatStreetInfo(vals, 3);
  let state = "Flat / Choppy";
  if(rn.flag || rs3.flag) state = "Repeat-Heavy";
  else {
    const w15 = vals.slice(0,15);
    const c15 = counts(w15);
    const colMax15 = Math.max(c15.c1,c15.c2,c15.c3);
    const dozMax15 = Math.max(c15.d1,c15.d2,c15.d3);
    if(colMax15 >= 7 || dozMax15 >= 7) state = "Concentrated";
  }

  return {state, plays: top3, primary};
}

// --- Extra diagnostics (repeats, Hydra cold4, Dirty Bird stats) ---
function findRepeatNumbers(spinsChrono, maxGap=5){
  // returns array of {n, gap} for repeats within maxGap (most recent occurrences)
  const lastIdx = new Map();
  const out = [];
  for(let i=0;i<spinsChrono.length;i++){
    const v = spinsChrono[i];
    if(v===0 || v==="00") continue;
    if(typeof v!=="number") continue;
    if(lastIdx.has(v)){
      const gap = i - lastIdx.get(v);
      if(gap<=maxGap) out.push({n:v, gap});
    }
    lastIdx.set(v,i);
  }
  // keep latest per number
  const best = new Map();
  out.forEach(o=>{ if(!best.has(o.n) || o.gap < best.get(o.n).gap) best.set(o.n,o); });
  return Array.from(best.values()).sort((a,b)=>a.gap-b.gap || a.n-b.n);
}

function streetOf(n){ return Math.floor((n-1)/3)+1; } // 1..12
function findRepeatStreets(spinsChrono, maxGap=3){
  const lastIdx = new Map();
  const out = [];
  for(let i=0;i<spinsChrono.length;i++){
    const v = spinsChrono[i];
    if(v===0 || v==="00") continue;
    if(typeof v!=="number") continue;
    const st = streetOf(v);
    if(lastIdx.has(st)){
      const gap = i - lastIdx.get(st);
      if(gap<=maxGap) out.push({st, gap});
    }
    lastIdx.set(st,i);
  }
  const best = new Map();
  out.forEach(o=>{ if(!best.has(o.st) || o.gap < best.get(o.st).gap) best.set(o.st,o); });
  return Array.from(best.values()).sort((a,b)=>a.gap-b.gap || a.st-b.st);
}

function sinceLastGreen(spinsChrono){
  for(let i=spinsChrono.length-1;i>=0;i--){
    const v=spinsChrono[i];
    if(v===0 || v==="00") return spinsChrono.slice(i+1);
  }
  return spinsChrono.slice();
}

function hydraCold4SinceGreen(spinsChrono){
  const seg = sinceLastGreen(spinsChrono);
  const counts = {};
  for(let n=1;n<=36;n++) counts[n]=0;
  seg.forEach(v=>{ if(typeof v==="number" && v>=1 && v<=36) counts[v]++; });
  const arr = Object.entries(counts).map(([k,c])=>({n:+k,c}));
  arr.sort((a,b)=>(a.c-b.c)||(a.n-b.n));
  const cold4 = arr.slice(0,4);
  return {len: seg.length, cold4};
}

// Dirty Bird selection (simplified stats-only: cold-dozen mode, 2 cold numbers excluded)
function dbcdsStatsLast15NoGreen(spinsChrono){
  // build last 15 non-green
  const win=[];
  for(let i=spinsChrono.length-1;i>=0 && win.length<15;i--){
    const v=spinsChrono[i];
    if(v===0 || v==="00") continue;
    if(typeof v==="number" && v>=1 && v<=36) win.push(v);
  }
  win.reverse();
  if(win.length<15) return {ok:false, need:15, have:win.length};
  const dzCounts={D1:0,D2:0,D3:0};
  win.forEach(n=>{ if(n<=12) dzCounts.D1++; else if(n<=24) dzCounts.D2++; else dzCounts.D3++;});
  const order=["D1","D2","D3"];
  let cold="D1", min=1e9;
  order.forEach(d=>{ if(dzCounts[d]<min){min=dzCounts[d]; cold=d;} });
  const minMax = Math.max(dzCounts.D1,dzCounts.D2,dzCounts.D3)-Math.min(dzCounts.D1,dzCounts.D2,dzCounts.D3);
  const minNum = cold==="D1"?1:(cold==="D2"?13:25);
  const maxNum = cold==="D1"?12:(cold==="D2"?24:36);
  const numCounts={};
  for(let n=minNum;n<=maxNum;n++) numCounts[n]=0;
  win.forEach(n=>{ if(n>=minNum && n<=maxNum) numCounts[n]++; });
  const entries = Object.entries(numCounts).map(([k,c])=>({n:+k,c}));
  entries.sort((a,b)=>(a.c-b.c)||(a.n-b.n));
  const excl=[entries[0].n, entries[1].n];
  const bet=[];
  for(let n=minNum;n<=maxNum;n++) if(!excl.includes(n)) bet.push(n);
  return {ok:true, dzCounts, coldDozen:cold, exclude:excl, bet10:bet.slice(0,10), gap:minMax};
}

// 12 Soldiers — Unique Columns selection (stats-only for tracker UI)
function soldiersNormalizeSpin(x){
  const s = String(x).trim();
  if (s === "00") return "00";
  const n = Number(s);
  if (!Number.isFinite(n)) throw new Error(`Invalid spin: ${x}`);
  if (n < 0 || n > 36) throw new Error(`Out of range spin: ${x}`);
  return Math.trunc(n);
}

function soldiersIsGreen(n){
  return n===0 || n==="00";
}

function soldiersColIndex(n){
  if (soldiersIsGreen(n)) return null;
  return ((n - 1) % 3) + 1;
}

function soldiersDozenNumbersByCol(dozen, col){
  const out=[];
  const start = dozen===1 ? 1 : dozen===2 ? 13 : 25;
  const end   = dozen===1 ? 12 : dozen===2 ? 24 : 36;
  for (let n=start;n<=end;n++) if (soldiersColIndex(n)===col) out.push(n);
  return out; // 4
}

function soldiersCountsInWindowNoGreen(window15){
  const counts = new Map();
  for (const n of window15){
    if (n==null || soldiersIsGreen(n)) continue;
    counts.set(n, (counts.get(n)||0)+1);
  }
  return counts;
}

function soldiersSpinsSinceLastHit(window15OldestToNewest, candidatesSet){
  for (let back=1; back<=window15OldestToNewest.length; back++){
    const n = window15OldestToNewest[window15OldestToNewest.length - back];
    if (n!=null && !soldiersIsGreen(n) && candidatesSet.has(n)) return back;
  }
  return 999;
}

function selectSoldiersUC(last15RawOldestToNewest){
  if (!Array.isArray(last15RawOldestToNewest) || last15RawOldestToNewest.length < 15) {
    throw new Error("selectSoldiersUC requires last 15 spins.");
  }
  const last15 = last15RawOldestToNewest.map(soldiersNormalizeSpin);
  const counts = soldiersCountsInWindowNoGreen(last15);
  function colScore(dozen, col){
    const nums = soldiersDozenNumbersByCol(dozen, col);
    const hits = nums.reduce((a,n)=>a+(counts.get(n)||0), 0);
    const age = soldiersSpinsSinceLastHit(last15, new Set(nums));
    return {hits, age, col, nums};
  }
  const d1Candidates=[1,2,3].map(c=>colScore(1,c));
  d1Candidates.sort((a,b)=>(a.hits-b.hits)||(b.age-a.age)||(a.col-b.col));
  const d1=d1Candidates[0];
  const remaining=[1,2,3].filter(c=>c!==d1.col);
  const d2Candidates=remaining.map(c=>colScore(2,c));
  d2Candidates.sort((a,b)=>(a.hits-b.hits)||(b.age-a.age)||(a.col-b.col));
  const d2=d2Candidates[0];
  const d3Col=[1,2,3].find(c=>c!==d1.col && c!==d2.col);
  const d3=colScore(3,d3Col);
  return {
    D1_ColIndex: d1.col,
    D2_ColIndex: d2.col,
    D3_ColIndex: d3.col,
    D1_Numbers: d1.nums,
    D2_Numbers: d2.nums,
    D3_Numbers: d3.nums,
    STAT_D1_DriestColIndex: d1.col,
    STAT_D1_DriestColNumbers: d1.nums,
    STAT_D1_DriestColHits_L15: d1.hits,
    STAT_D1_DriestColSpinsSinceLastHit_L15: d1.age,
  };
}

function soldiersStatsLast15(recentNewestFirst){
  if (!Array.isArray(recentNewestFirst) || recentNewestFirst.length < 15) {
    return {ok:false, need:15, have:(recentNewestFirst||[]).length};
  }
  try{
    const last15Oldest = recentNewestFirst.slice(0,15).slice().reverse();
    const sel = selectSoldiersUC(last15Oldest);
    return {ok:true, sel};
  }catch(e){
    return {ok:false, err:String(e && e.message ? e.message : e)};
  }
}

/* === RENDER LOOP (LOCKED) — DO NOT EDIT === */

function render() {
  try {
    $("winLabel").textContent = "Last " + windowN;
    $("spinCount").textContent = String(spins.length);
    $("sessionCount").textContent = String(spins.filter(x => x.s===sessionId).length);

    const recent = windowValues();
    $("greenCount").textContent = String(recent.filter(isGreen).length);

    const cts = counts(recent);
    const cAges = colAges(recent);
    const dAges = dozenAges(recent);
    const fmtAgeCD = (a) => (a === 999 ? (recent.length + "+") : String(a));
    $("cols").textContent = `${cts.c1} (${fmtAgeCD(cAges.c1)}) / ${cts.c2} (${fmtAgeCD(cAges.c2)}) / ${cts.c3} (${fmtAgeCD(cAges.c3)})`;
    $("doz").textContent  = `${cts.d1} (${fmtAgeCD(dAges.d1)}) / ${cts.d2} (${fmtAgeCD(dAges.d2)}) / ${cts.d3} (${fmtAgeCD(dAges.d3)})`;

    const dsc = dsCounts(recent);
    $("ds").textContent = `D1 ${dsc.d1[0]}/${dsc.d1[1]}/${dsc.d1[2]} | D2 ${dsc.d2[0]}/${dsc.d2[1]}/${dsc.d2[2]} | D3 ${dsc.d3[0]}/${dsc.d3[1]}/${dsc.d3[2]}`;

    $("rb").textContent   = `${cts.red} / ${cts.black}`;
    $("hl").textContent   = `${cts.high} / ${cts.low}`;
    $("eo").textContent   = `${cts.even} / ${cts.odd}`;
        const jAges = junkoAges(recent);
    const fmtAge = (a) => (a === 999 ? (recent.length + "+") : String(a));
    $("junko").textContent = "GN " + cts.gn + " (" + fmtAge(jAges.gn) + ") | HO " + cts.ho + " (" + fmtAge(jAges.ho) + ") | LO " + cts.lo + " (" + fmtAge(jAges.lo) + ") | M " + cts.m + " (" + fmtAge(jAges.m) + ")";

    $("lastList").value = spins.slice(0,20).map(x => (x.n==="00"?"00":String(x.n))).join(", ");

    const scored = scoreStrategies(recent);
    $("recommend").textContent = `${scored.primary.mode} — ${scored.primary.name}`;
    $("reason").textContent = scored.primary.why || "—";
    // ---- GSAH-15 add-on (0/00 split hedge) ----
    const mainBetting = (String(scored.primary.mode || "").toLowerCase() !== "sit out");

    // Arm when drought >=15 and not in cooldown
    if (!gsah.cooldown && (Number.isFinite(gdc) ? gdc : 0) >= 15 && gsah.state === "OFF") {
      gsah.state = "ARMED";
      gsah.offReason = "";
    }

    // If green has hit, cooldown clears (redundant safety)
    if ((Number.isFinite(gdc) ? gdc : 0) === 0 && gsah.cooldown) gsah.cooldown = false;

    // Decide if hedge will bet on NEXT spin (only when primary is betting)
    gsah.pending = false;
    if (gsah.state === "ARMED" && mainBetting) gsah.state = "ACTIVE";
    if (gsah.state === "ACTIVE" && mainBetting) {
      gsah.pending = true;
      gsah.pendingU = Number.isFinite(gsah.u) ? gsah.u : 1;
    }

    const status = gsah.cooldown
      ? `OFF (cooldown) — ${gsah.offReason || "—"}`
      : (gsah.state === "OFF" ? "OFF" : (gsah.state === "ARMED" ? "ARMED (GDC≥15)" : "ACTIVE"));

    const nextBet = (gsah.pending && mainBetting)
      ? `Next spin: bet 0/00 split u=${gsah.pendingU}`
      : "Next spin: —";

    $("gsah").textContent = status;
    $("gsah2").textContent = `${nextBet} • u=${gsah.u||1} • losses=${gsah.lossCount||0} • betSpins=${gsah.betSpins||0} • pnl=${gsah.pnlU||0}u`;

    $("state").textContent = scored.state;
    $("state2").textContent = `Window: last ${windowN} • Session: ${sessionId}`;
    // Extra diagnostics
    const repNums = findRepeatNumbers(recent, 5);
    $("repNums").textContent = repNums.length ? repNums.map(o=>`${o.n} (gap ${o.gap})`).join(", ") : "—";
    $("repNums2").textContent = repNums.length ? `count: ${repNums.length}` : "—";

    const repSt = findRepeatStreets(recent, 3);
    $("repStreets").textContent = repSt.length ? repSt.map(o=>`S${o.st} (gap ${o.gap})`).join(", ") : "—";
    $("repStreets2").textContent = repSt.length ? `count: ${repSt.length}` : "—";

    const hc = hydraCold4SinceGreen(recent);
    $("hydraCold4").textContent = hc.cold4.map(o=>`${o.n}(${o.c})`).join("  ");
    $("hydraCold4b").textContent = `spins since green: ${hc.len}`;

    const db = dbcdsStatsLast15NoGreen(recent);
    if(db.ok){
      $("dbcds").textContent = `Bet ${db.coldDozen} (cold). Exclude ${db.exclude.join(", ")}.`;
      $("dbcds2").textContent = `D1:${db.dzCounts.D1} D2:${db.dzCounts.D2} D3:${db.dzCounts.D3} • gap ${db.gap}`;
    }else{
      $("dbcds").textContent = `Need 15 non‑green; have ${db.have}`;
      $("dbcds2").textContent = "—";
    }

    // 12 Soldiers selection stats (last 15 spins)
    const sld = soldiersStatsLast15(recent);
    if(sld.ok){
      $("soldiers").textContent = `D1 C${sld.sel.D1_ColIndex} | D2 C${sld.sel.D2_ColIndex} | D3 C${sld.sel.D3_ColIndex}`;
      $("soldiers2").textContent = `D1 nums: ${sld.sel.D1_Numbers.join(",")} • hits ${sld.sel.STAT_D1_DriestColHits_L15} • age ${sld.sel.STAT_D1_DriestColSpinsSinceLastHit_L15}`;
    }else{
      $("soldiers").textContent = `Need 15 spins; have ${sld.have}`;
      $("soldiers2").textContent = "—";
    }


    // Top plays cards
    const topPlays = $("topPlays");
    topPlays.innerHTML = "";
    scored.plays.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "playcard";
      div.innerHTML = `
        <div class="playhdr">
          <div>
            <div style="font-weight:900">${idx+1}. ${p.mode} — ${p.name}</div>
            <div class="small">${(p.why||"—").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
            ${p.betText ? `<div class="small" style="margin-top:6px"><b>Bet:</b> ${(p.betText||"").replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>` : ""}
            ${p.key==="MOON_DANCE" && p.md_picks ? `<div class="small" style="margin-top:6px"><b>Streets:</b> D1 ${p.md_picks.D1[0].range} & ${p.md_picks.D1[1].range} • D2 ${p.md_picks.D2[0].range} & ${p.md_picks.D2[1].range} • D3 ${p.md_picks.D3[0].range} & ${p.md_picks.D3[1].range}</div>` : ""}
            ${p.numbers && p.numbers.length ? `<div class="small" style="margin-top:6px"><b>Numbers:</b> ${p.numbers.join(", ")}</div>` : ""}
          </div>
          <div class="tag">${p.mode} • ${p.score}</div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn small" data-exp="${p.name}">Explain</button>
        </div>
      `;
      topPlays.appendChild(div);
    });
    [...topPlays.querySelectorAll("button[data-exp]")].forEach(b => {
      b.addEventListener("click", () => showExplain(b.getAttribute("data-exp")));
    });

    // Primary explain button
    const pb = $("primaryExplainBtn");
    if(STRATEGY_DETAILS[scored.primary.name] && scored.primary.name !== "Sit out") {
      pb.style.display = "inline-block";
      pb.onclick = () => showExplain(scored.primary.name);
    } else {
      pb.style.display = "none";
      pb.onclick = null;
    }
  
    
  } catch(e) {
    console.error('Render error', e);
    try { const rr = $("reason"); if (rr) rr.textContent = 'Render error: ' + (e && (e.message || e.toString()) || e); } catch(_) {}
    try { const rc = $("recommend"); if (rc && rc.textContent === 'Sit out') rc.textContent = 'Render error'; } catch(_) {}
  }
// Rebuild keypad after every render (render() replaces the DOM and can wipe it)
    try { buildKeypad(); } catch(e) { console.warn('Keypad build failed', e); }
}

  // UI wiring
  on("undoBtn", "click", undo);
  on("clearBtn", "click", clearAll);
  on("use15Btn", "click", () => { windowN=15; save(); render(); });
  on("use10Btn", "click", () => { windowN=10; save(); render(); });
  on("use20Btn", "click", () => { windowN=20; save(); render(); });
  on("newSessionBtn", "click", newSession);

  on("addManualBtn", "click", () => {
    const raw = ($("manualInput").value||"").trim();
    if(!raw) return;
    if(raw === "00") addSpin("00");
    else if(/^[0-9]+$/.test(raw)) addSpin(Number(raw));
    $("manualInput").value = "";
  });
  on("manualInput", "keydown", (e) => {
    if(e.key === "Enter") {
      e.preventDefault();
      $("addManualBtn").click();
    }
  });

  on("casinoInput", "input", save);

  on("copyCsvBtn", "click", copyCsv);
  on("downloadCsvBtn", "click", downloadCsv);

  on("importBtn", "click", () => {
    const res = importCsvText($("importArea").value);
    $("importStatus").textContent = res.msg;
  });
  on("clearImportBtn", "click", () => {
    $("importArea").value = "";
    $("importStatus").textContent = "";
  });

    // ---------------- Wheel View (Last 20) ----------------
    const WHEEL = [0,28,9,26,30,11,7,20,32,17,5,22,34,15,3,24,36,13,1,"00",27,10,25,29,12,8,19,31,18,6,21,33,16,4,23,35,14,2];

    function numLabel(n){ return (n === "00") ? "00" : String(n); }

    function pocketColor(n){
      if(n === 0 || n === "00") return "rgba(80, 220, 160, 0.95)"; // green
      const v = Number(n);
      return (RED[v] ? "rgba(255, 92, 92, 0.95)" : "rgba(70, 140, 255, 0.95)"); // red / black-blue
    }

    function drawWheelHistogram(lastN=20){
      const canvas = document.getElementById("wheelCanvas");
      if(!canvas) return;
      const ctx = canvas.getContext("2d");

      // HiDPI crispness
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || 420;
      const size = Math.min(cssW, 520);
      canvas.style.height = size + "px";
      canvas.style.width  = size + "px";
      canvas.width  = Math.floor(size * dpr);
      canvas.height = Math.floor(size * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      ctx.clearRect(0,0,size,size);

      const cx = size/2, cy = size/2;
      const outerR = (size/2) - 16;
      const ringR1 = outerR - 46;
      const innerR = 54;
      const barLen = 10;
      const barGap = 2;
      const step = (Math.PI*2)/WHEEL.length;
      const start = -Math.PI/2;

      // count last N spins (spins is newest-first)
      const slice = spins.slice(0, lastN);
      const cts = {};
      for(const x of slice){
        const k = (x.n === "00") ? "00" : String(x.n);
        cts[k] = (cts[k]||0) + 1;
      }
      let maxC = 0;
      for(const n of WHEEL) maxC = Math.max(maxC, cts[numLabel(n)]||0);

      // background rings
      ctx.beginPath();
      ctx.arc(cx,cy,outerR,0,Math.PI*2);
      ctx.fillStyle="rgba(255,255,255,0.04)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(cx,cy,ringR1,0,Math.PI*2);
      ctx.fillStyle="rgba(0,0,0,0.18)";
      ctx.fill();

      for(let k=0;k<WHEEL.length;k++){
        const a0 = start + k*step;
        const a1 = a0 + step;

        ctx.beginPath();
        ctx.moveTo(cx + ringR1*Math.cos(a0), cy + ringR1*Math.sin(a0));
        ctx.arc(cx,cy,ringR1,a0,a1);
        ctx.lineTo(cx + outerR*Math.cos(a1), cy + outerR*Math.sin(a1));
        ctx.arc(cx,cy,outerR,a1,a0,true);
        ctx.closePath();

        ctx.fillStyle="rgba(255,255,255,0.02)";
        ctx.fill();
        ctx.strokeStyle="rgba(255,255,255,0.06)";
        ctx.lineWidth=1;
        ctx.stroke();

        const n = WHEEL[k];
        const key = numLabel(n);
        const c = cts[key]||0;

        if(c>0){
          const aw = step*0.72;
          const mid = (a0+a1)/2;
          for(let s=0;s<c;s++){
            const r1 = innerR + s*(barLen+barGap);
            const r2 = r1 + barLen;
            ctx.beginPath();
            ctx.moveTo(cx + r1*Math.cos(mid-aw/2), cy + r1*Math.sin(mid-aw/2));
            ctx.arc(cx,cy,r1, mid-aw/2, mid+aw/2);
            ctx.lineTo(cx + r2*Math.cos(mid+aw/2), cy + r2*Math.sin(mid+aw/2));
            ctx.arc(cx,cy,r2, mid+aw/2, mid-aw/2, true);
            ctx.closePath();

            ctx.fillStyle = pocketColor(key);
            ctx.globalAlpha = 0.25 + 0.75*((s+1)/Math.max(1,maxC));
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        // label
        const midA = (a0+a1)/2;
        const tx = cx + (outerR-18)*Math.cos(midA);
        const ty = cy + (outerR-18)*Math.sin(midA);
        ctx.save();
        ctx.translate(tx,ty);
        ctx.rotate(midA + Math.PI/2);
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
        ctx.fillStyle="rgba(255,255,255,0.85)";
        ctx.fillText(key, 0, 0);
        ctx.restore();

        // count badge
        if(c>0){
          const bx = cx + (ringR1+18)*Math.cos(midA);
          const by = cy + (ringR1+18)*Math.sin(midA);
          ctx.beginPath();
          ctx.arc(bx,by,10,0,Math.PI*2);
          ctx.fillStyle="rgba(0,0,0,0.35)";
          ctx.fill();
          ctx.strokeStyle="rgba(255,255,255,0.12)";
          ctx.stroke();

          ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
          ctx.fillStyle="rgba(255,255,255,0.95)";
          ctx.textAlign="center";
          ctx.textBaseline="middle";
          ctx.fillText(String(c), bx, by);
        }
      }

      // center label
      ctx.beginPath();
      ctx.arc(cx,cy,innerR-14,0,Math.PI*2);
      ctx.fillStyle="rgba(0,0,0,0.30)";
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,0.10)";
      ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="14px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText("LAST " + lastN, cx, cy-10);
      ctx.font="12px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
      ctx.fillStyle="rgba(255,255,255,0.70)";
      ctx.fillText("hit histogram", cx, cy+10);
    }

    function openWheelModal(){
      const m = document.getElementById("wheelModal");
      if(!m) return;
      m.style.display = "flex";
      drawWheelHistogram(20);
    }
    function closeWheelModal(){
      const m = document.getElementById("wheelModal");
      if(m) m.style.display = "none";
    }

    const wheelBtn = document.getElementById("wheelViewBtn");
    if(wheelBtn) wheelBtn.addEventListener("click", openWheelModal);

    const wheelClose = document.getElementById("wheelCloseBtn");
    if(wheelClose) wheelClose.addEventListener("click", closeWheelModal);

    const wheelModal = document.getElementById("wheelModal");
    if(wheelModal) wheelModal.addEventListener("click", (e)=>{ if(e.target && e.target.id==="wheelModal") closeWheelModal(); });

    window.addEventListener("resize", ()=>{ if(wheelModal && wheelModal.style.display !== "none") drawWheelHistogram(20); });
  load();

  if(trendDismissBtn){
    trendDismissBtn.onclick = function(){ if(trendAlert) trendAlert.style.display="none"; };
  }
render();
});

/* === WHEEL WAVE TRACKER (SAFE ADD-ON) ===
   Output: seg10/seg15 { state, sameRate, oppRate }
   band=3 means |Δnumber|<=3 counts as SAME.
*/
function createWheelWaveTracker({ band = 3 } = {}) {
  const spins = [];
  function analyze(n) {
    if (spins.length < n) return null;
    const win = spins.slice(-n);
    let same = 0, opp = 0;
    for (let i = 1; i < win.length; i++) {
      if (Math.abs(win[i] - win[i-1]) <= band) same++;
      else opp++;
    }
    const total = same + opp || 1;
    return {
      state: same > opp ? "SAME" : (opp > same ? "OPP" : "NEUTRAL"),
      sameRate: +(same / total).toFixed(2),
      oppRate: +(opp / total).toFixed(2)
    };
  }
  return {
    pushSpin(v) {
      if (typeof v !== "number" || v < 0 || v > 36) return { error: "Invalid spin" };
      spins.push(v);
      return { seg10: analyze(10), seg15: analyze(15) };
    }
  };
}
const wheelWave = createWheelWaveTracker({ band: 3 });
function wheelWaveCount(){ return (wheelWave && wheelWave._count) ? wheelWave._count() : 0; }

function __waveUpdateFromSpin(val){
  const out = wheelWave.pushSpin(val);
  if(out && out.error){ return; }
  if(out && out.seg10){
    const el10 = document.getElementById("wave10");
    if(el10) el10.textContent = out.seg10.state + " | same " + out.seg10.sameRate + " / opp " + out.seg10.oppRate;
  }
  if(out && out.seg15){
    const el15 = document.getElementById("wave15");
    if(el15) el15.textContent = out.seg15.state + " | same " + out.seg15.sameRate + " / opp " + out.seg15.oppRate;
  }
}

/* === WHEEL WAVE HOOK (NON-INVASIVE) === */
(function(){
  const __origAddSpin = addSpin;
  addSpin = function(val){
    __origAddSpin(val);

    // Normalize exactly like the tracker does
    try{
      const k = (typeof numToKey === "function") ? numToKey(val) : null;
      if(k===null) return;

      // Map "00" -> 0 for this stat; keep 0 as 0
      const n = (k === "00") ? 0 : parseInt(k, 10);
      if(!Number.isFinite(n)) return;

      __waveUpdateFromSpin(n);

      // Show "Need N more" until the windows are full (helps confirm it is ingesting)
      const c = wheelWaveCount();
      const el10 = document.getElementById("wave10");
      const el15 = document.getElementById("wave15");
      if(el10 && !el10.textContent) el10.textContent = "—";
      if(el15 && !el15.textContent) el15.textContent = "—";

      if(el10 && c < 10) el10.textContent = "Need " + (10 - c) + " more";
      if(el15 && c < 15) el15.textContent = "Need " + (15 - c) + " more";
    }catch(e){
      // swallow: never break UI
    }
  };
})();
</script>
</body>
</html>